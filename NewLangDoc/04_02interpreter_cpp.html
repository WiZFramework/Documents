<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０４．インタプリタの作成</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０４－０２．interpreter.cpp</h3>
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include "util.h"
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    struct Root::Impl {
        const StatementList* m_StatementList;
    };

    Root::Root(const StatementList* stml) :
        StmExBase(ObjType::RootType),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }

    Root::~Root() {
        delete pImpl;
    }

    const StatementList* Root::getStmeList()const {
        return pImpl->m_StatementList;
    }

    SmtRes Root::Excute()const {
        setRuntimeLineNumber();
        if (pImpl->m_StatementList) {
            auto pos = pImpl->m_StatementList;
            do {
                auto stm = pos->getStm();
                if (typeid(*stm) != typeid(FunctionDefineStm)) {
                    stm->Excute();
                }
                pos = pos->getNext();
            } while (pos);
        }
        else {
            Interpreter::getInp()->runtimeExit(2001);
        }
        return SmtRes();
    }

    //--------------------------------------------------------------------------------------
    ///  ランタイムオブジェクト
    //--------------------------------------------------------------------------------------
    struct RuntimeObject : public std::enable_shared_from_this&lt;RuntimeObject> {
        bool m_IsFunc;
        //変数のmap
        map&lt;string, Value> m_VariableMap;
        //ツリー構造
        weak_ptr&lt;RuntimeObject> m_Parent;
        shared_ptr&lt;RuntimeObject> m_Child;
        RuntimeObject(shared_ptr&lt;RuntimeObject> parent, bool IsFunc = false) :
            m_Parent(parent), m_Child(nullptr), m_IsFunc(IsFunc)
        {}
        ~RuntimeObject() {}
    };

    //--------------------------------------------------------------------------------------
    ///  インタープリタクラス
    //--------------------------------------------------------------------------------------
    Interpreter* Interpreter::getInp() {
        static Interpreter* instance = nullptr;
        if (!instance) {
            instance = new Interpreter;
        }
        return instance;
    }

    struct Interpreter::Impl {
        set&lt;string> m_FixedStringPool;
        vector&lt;ObjBase*> m_ObjectPool;
        map&lt;string, string> m_ConfigMap;
        map&lt;string, FunctionDefineStm*> m_FunctionMap;
        //文字列リテラル作成用
        string m_LiteralTemp;
        //ランタイムエラー用テンポラリ
        Value m_TempVal;
        Root* m_Root;
        shared_ptr&lt;RuntimeObject> m_CurrentRuntime;
        shared_ptr&lt;RuntimeObject> m_RootRuntime;
        //エラーのマップ
        map&lt;int, string> m_ErrMap;
        //警告を表示するかどうか
        bool m_IsWorningOut;
        //今関数の実行中かどうか
        bool m_FunctionRuntime;
        //ランタイム中の行番号
        int m_RuntimeLineNumber;
        //breakの深さ
        int m_BreakDeps;
        //Loopの深さ
        int m_LoopDeps;
    };

    Interpreter::Interpreter() :
        ObjBase(ObjType::InterpreterType),
        pImpl(new Impl)
    {
        pImpl->m_Root = nullptr;
        pImpl->m_ErrMap =
        {
            { 0001, "をみでくんつえ。" },
            { 0002, "その手前がもしんねぞい。" },
            { 1001, "ファイルのなめえ（名前）が指定されてないぞい。" },
            { 1002, "ファイルを読むのに失敗したぞい。" },
            { 1003, "書ぎがだがまじがってんぞい。" },
            { 1004, "関数名はすでにつかわれでっつおい。"},
            { 1005, "関数が見づがんねぞい。ない関数を呼んだってだめだべ。よぶどごより上で作ってくんつえ。"},
            { 2001, "実行文がねがら動がせねぞい。" },
            { 2002, "なんだがわがんねエラーだぞい" },
            { 2003, "0では割れねぞい。んなごど、とっぐにわがってっぺ。" },
            { 2004, "演算でぎねぞい"},
            { 2005, "右辺が負の数だと文字列の掛け算はでぎねぞい。正の数字ならでぎっつおい。" },
            { 2006, "左辺が文字列だと引き算でぎねぞい。足し算か掛け算ならでぎっつおい。" },
            { 2007, "左辺が文字列だと割り算でぎねぞい。足し算か掛け算ならでぎっつおい。" },
            { 2008, "bool型はほかの型とは比較でぎねぞい。bool同士ならでぎっつおい。" },
            { 2009, "文字列は比較でぎねぞい" },
            { 2010, "比較演算がでぎねぞい"},
            { 2011, "ローカル変数は関数のながでしがつぐれねぞい。"},
            { 2012, "定義関数で、キーが空白でねえがい？"},
            { 2013, "関数呼び出しで、パラメータ数より実引数が多いぞい。関数定義をよぐみでくんつえ。"},
            { 2014, "関数のながに関数をづぐろうどしてんべ。すまねが、それはでぎんよ。"},
            { 2015, "なんだがわがんねげど、ループがスイッチが開いてねえが閉じてねえどごがあんぞい。"},
            { 2016, "ブレーク文はループの中がスイッチのながしかかげねぞい。"},
            { 2017, "リターン文は関数内でしかかげねぞい。"},
            { 2018, "コンティニュー文はループの中しかかげねぞい。"},
            { 2019, "配列の添え字は正の整数か文字列だぞい"},
            { 2020, "親配列がないぞい"},
            { 2021, "配列はほがの型に変換でぎねぞい。"},
            { 2022, "その配列の添え字はめっかんねぞい。"},
        };

        //初期状態はワーニングを出す
        pImpl->m_IsWorningOut = true;
        pImpl->m_RuntimeLineNumber = 1;
        pImpl->m_TempVal = Value();
        pImpl->m_ConfigMap["calc_epsilon"] = "0.000001";
        pImpl->m_FunctionRuntime = false;
        pImpl->m_BreakDeps = 0;
        pImpl->m_LoopDeps = 0;
    }
    Interpreter::~Interpreter() {
        delete pImpl;
    }

    int Interpreter::Compile(FILE *fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;
    }

    void Interpreter::Exec()const {
        if (pImpl->m_Root) {
            pImpl->m_CurrentRuntime = make_shared&lt;RuntimeObject>(nullptr);
            pImpl->m_RootRuntime = pImpl->m_CurrentRuntime;
            pImpl->m_Root->Excute();
        }
        else {
            Interpreter::getInp()->runtimeExit(2001);
        }
    }

    ///１階層ランタイムをpushする
    void Interpreter::pushRuntime(bool IsFunc) {
        pImpl->m_CurrentRuntime->m_Child = make_shared&lt;RuntimeObject>(pImpl->m_CurrentRuntime, IsFunc);
        pImpl->m_CurrentRuntime = pImpl->m_CurrentRuntime->m_Child;
    }
    ///１階層ランタイムをpopする
    void Interpreter::popRuntime() {
        auto parPtr = pImpl->m_CurrentRuntime->m_Parent.lock();
        if (parPtr) {
            pImpl->m_CurrentRuntime = parPtr;
            pImpl->m_CurrentRuntime->m_Child.reset();
        }
    }

    //ループ実行中かどうか
    void Interpreter::pushLoop() {
        pImpl->m_LoopDeps++;

    }
    void Interpreter::popLoop() {
        pImpl->m_LoopDeps--;
        if (pImpl->m_LoopDeps &lt; 0) {
            Interpreter::getInp()->runtimeExit(2015);
        }
    }
    //continue可能かどうか
    bool Interpreter::isContinueOK() const {
        if (pImpl->m_LoopDeps > 0) {
            return true;
        }
        return false;
    }



    void Interpreter::pushBreak() {
        pImpl->m_BreakDeps++;

    }

    void Interpreter::popBreak() {
        pImpl->m_BreakDeps--;
        if (pImpl->m_BreakDeps &lt; 0) {
            Interpreter::getInp()->runtimeExit(2015);
        }
    }

    bool Interpreter::isBreakOK() const {
        if (pImpl->m_BreakDeps > 0) {
            return true;
        }
        return false;
    }

    void Interpreter::setFunctionRuntime(bool b) {
        pImpl->m_FunctionRuntime = b;

    }

    bool Interpreter::isFunctionRuntime() const {
        return pImpl->m_FunctionRuntime;
    }

    void Interpreter::Delete() {
        for (auto v : pImpl->m_ObjectPool) {
            delete v;
        }
        pImpl->m_ObjectPool.clear();
        pImpl->m_FixedStringPool.clear();
    }

    void Interpreter::setConfig(const char* key, const Value val) {
        //congigファイルは文字列
        string keystr = key;
        string valstr = val.getString();
        if (keystr == "") {
            runtimeExit(2012);
        }
        pImpl->m_ConfigMap[keystr] = valstr;
    }

    Value Interpreter::getConfig(const char* key) {
        //congigファイルは文字列
        string keystr = key;
        if (keystr == "") {
            runtimeExit(2012);
        }
        return Value(pImpl->m_ConfigMap[keystr].c_str());
    }

    void Interpreter::pushBackObject(ObjBase* pobj) {
        pImpl->m_ObjectPool.push_back(pobj);
    }

    const char* Interpreter::createFixedString(const char* ext) {
        //255文字に切り詰める。
        auto str = clampToken(ext);
        auto it = pImpl->m_FixedStringPool.insert(str);
        return it.first->c_str();
    }

    Expression* Interpreter::createVariableExp(const char* ident, bool isLocal) {
        string str = clampToken(ident);
        auto ptr = new VariableExp(str.c_str(), isLocal);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createArrayInitValueExp(const ArgumentList* argumentList) {
        auto ptr = new ArrayInitValueExp(argumentList);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createArrayInitKeyValueExp(const ArrKeyValueList* arrKeyValueList) {
        auto ptr = new ArrayInitKeyValueExp(arrKeyValueList);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ArrKeyValueList* Interpreter::createArrKeyValueList(const Expression* key, const Expression* value) {
        auto ptr = new ArrKeyValueList(key, value);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ArrKeyValueList* Interpreter::createArrKeyValueList(ArrKeyValueList* prev, const Expression* key, const Expression* value) {
        ArrKeyValueList* pos;
        if (prev == nullptr)
            return createArrKeyValueList(key, value);
        for (pos = prev; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createArrKeyValueList(key,value));
        return prev;
    }

    ArrKeytList* Interpreter::createArrKeytList() {
        auto ptr = new ArrKeytList();
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ArrKeytList* Interpreter::createArrKeytList(const Expression* key) {
        auto ptr = new ArrKeytList(key);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }
    ArrKeytList* Interpreter::createArrKeytList(ArrKeytList* parent, const Expression* key) {
        ArrKeytList* pos;
        if (parent == nullptr)
            return createArrKeytList(key);
        for (pos = parent; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createArrKeytList(key));
        return parent;
    }


    Expression* Interpreter::createArrayExp(const char* ident,ArrKeytList* keylist, bool isLocal) {
        string str = clampToken(ident);
        auto ptr = new ArrayExp(str.c_str(), keylist, isLocal);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createPriorityExp(const Expression* target) {
        auto ptr = new PriorityExp(target);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createBoolLiteralExp(bool b) {
        auto ptr = new BoolLiteralExp(b);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createIntLiteralExp(const char* ext) {
        string str = clampToken(ext);
        auto ptr = new IntLiteralExp(std::stoi(str));
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createDoubleLiteralExp(const char* ext) {
        string str = clampToken(ext);
        auto ptr = new DoubleLiteralExp(std::stod(str));
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createBinaryExp(const Expression* left, const Expression* right, ExpressionType t) {
        auto ptr = new BinaryExp(t, left, right);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createRelationalExp(const Expression* left, const Expression* right, ExpressionType t) {
        auto ptr = new RelationalExp(t, left, right);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createAssExp(const Expression* ident, const Expression* right) {
        auto ptr = new AssignExp(ident, right);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createAssignArrExp(const Expression* variable,  const Expression* operand) {
        auto ptr = new AssignArrExp(variable, operand);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createToAssExp(const Expression* ident, const Expression* right, ExpressionType t) {
        auto ptr = new ToAssExp(ident, right, t);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createUnaryIncDecExp(const Expression* ident, ExpressionType t) {
        auto ptr = new UnaryIncDecExp(ident, t);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createPostfixIncDecExp(const Expression* ident, ExpressionType t) {
        auto ptr = new PostfixIncDecExp(ident, t);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ArgumentList* Interpreter::createArgumentList() {
        auto ptr = new ArgumentList();
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ArgumentList* Interpreter::createArgumentList(const Expression* exp) {
        auto ptr = new ArgumentList(exp);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;

    }

    ArgumentList* Interpreter::createArgumentList(ArgumentList* agl, const Expression* exp) {
        ArgumentList* pos;
        if (agl == nullptr)
            return createArgumentList(exp);
        for (pos = agl; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createArgumentList(exp));
        return agl;
    }

    Expression* Interpreter::createFunctionCallExp(const char* ident, const ArgumentList* args) {
        extern int gLine;
        auto it = pImpl->m_FunctionMap.find(ident);
        if (it == pImpl->m_FunctionMap.end()) {
            //その名前の関数がなかった
            syntaxExit(1005, gLine, ident, false);
        }
        auto ptr = new FunctionCallExp(ident, args, pImpl->m_FunctionMap[ident]);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    void Interpreter::startStringLiteral() {
        pImpl->m_LiteralTemp = "";
    }

    void Interpreter::addStringLiteral(char ext) {
        pImpl->m_LiteralTemp += ext;
    }

    Expression* Interpreter::createStringLiteralExp() {
        auto ptr = new StringLiteralExp(pImpl->m_LiteralTemp.c_str());
        pImpl->m_LiteralTemp = "";
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ExpressionList* Interpreter::createExpressiontList(const Expression* exp) {
        auto ptr = new ExpressionList(exp);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ExpressionList* Interpreter::createExpressiontList(ExpressionList* expl, const Expression* exp) {
        ExpressionList *pos;
        if (expl == nullptr)
            return createExpressiontList(exp);
        for (pos = expl; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createExpressiontList(exp));
        return expl;
    }

    StatementList* Interpreter::createStatementList(const Statement* stm) {
        auto ptr = new StatementList(stm);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    StatementList* Interpreter::createStatementList(StatementList* stml, const Statement* stm) {
        StatementList *pos;
        if (stml == nullptr)
            return createStatementList(stm);
        for (pos = stml; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createStatementList(stm));
        return stml;
    }

    ParameterList* Interpreter::createParameterList() {
        auto ptr = new ParameterList();
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ParameterList* Interpreter::createParameterList(const char* ident) {
        auto ptr = new ParameterList(ident);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    ParameterList* Interpreter::createParameterList(ParameterList* pml, const char* ident) {
        ParameterList *pos;
        if (pml == nullptr)
            return createParameterList(ident);
        for (pos = pml; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createParameterList(ident));
        return pml;
    }

    Statement* Interpreter::createFunctionDefineStm(const char* ident, const ParameterList* pml, const Statement* stm) {
        extern int gLine;
        auto it = pImpl->m_FunctionMap.find(ident);
        if (it != pImpl->m_FunctionMap.end()) {
            //すでにその名前の関数があった
            syntaxExit(1004, gLine, ident, false);
        }
        auto ptr = new FunctionDefineStm(ident, pml, stm);
        pImpl->m_ObjectPool.push_back(ptr);
        pImpl->m_FunctionMap[ident] = ptr;
        return ptr;
    }

    Root*  Interpreter::createRoot(const StatementList* stml) {
        auto ptr = new Root(stml);
        pImpl->m_ObjectPool.push_back(ptr);
        //インタプリタのrootにセット
        pImpl->m_Root = ptr;
        return ptr;
    }

    ///変数の値を取得
    Value& Interpreter::getGlobalValiableValue(const char* key) {
        //ルートの変数（グローバル変数）を得る
        auto it = pImpl->m_RootRuntime->m_VariableMap.find(key);
        if (it != pImpl->m_RootRuntime->m_VariableMap.end()) {
            //見つかった
            return it->second;
        }
        else {
            //無かったので作成
            //stringで作成
            pImpl->m_RootRuntime->m_VariableMap[key] = Value("");
            return pImpl->m_RootRuntime->m_VariableMap[key];
        }
    }

    bool Interpreter::findLocalValiableValue(const char* key) {
        auto tgtRuntime = pImpl->m_CurrentRuntime;
        do {
            if (tgtRuntime->m_IsFunc) {
                auto it = tgtRuntime->m_VariableMap.find(key);
                if (it != tgtRuntime->m_VariableMap.end()) {
                    //見つかった
                    return true;
                }
                else {
                    return false;
                }
            }
            tgtRuntime = tgtRuntime->m_Parent.lock();
        } while (tgtRuntime);
        //ルートまでさかのぼってしまった。
        return false;
    }

    Value& Interpreter::getLocalValiableValue(const char* key) {
        auto tgtRuntime = pImpl->m_CurrentRuntime;
        do {
            if (tgtRuntime->m_IsFunc) {
                auto it = tgtRuntime->m_VariableMap.find(key);
                if (it != tgtRuntime->m_VariableMap.end()) {
                    //見つかった
                    return it->second;
                }
                else {
                    //無かったので作成
                    //stringで作成
                    tgtRuntime->m_VariableMap[key] = Value("");
                    return tgtRuntime->m_VariableMap[key];
                }
            }
            tgtRuntime = tgtRuntime->m_Parent.lock();
        } while (tgtRuntime);
        //ルートまでさかのぼってしまった。
        runtimeExit(2011, key);
        return pImpl->m_TempVal;
    }

    void Interpreter::setRuntimeLineNumber(int num) {
        pImpl->m_RuntimeLineNumber = num;

    }
    int Interpreter::getRuntimeLineNumber() const {
        return pImpl->m_RuntimeLineNumber;
    }

    void Interpreter::syntaxKeepExit(int mess_id, const char* detail) {
        cerr &lt;&lt; "\n"
            &lt;&lt; pImpl->m_ErrMap[1003]
            &lt;&lt; detail
            &lt;&lt; ": "
            &lt;&lt; pImpl->m_ErrMap[mess_id]
            &lt;&lt; endl;
        exit(1);
    }


    void Interpreter::syntaxExit(int mess_id, int linnum, const char* detail, bool bison) {
        string detailstr = detail;
        if (bison) {
            if (detailstr != "") {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目: "
                    &lt;&lt; detailstr
                    &lt;&lt; " あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; pImpl->m_ErrMap[0002]
                    &lt;&lt; endl;
            }
            else {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; endl;

            }
        }
        else {
            if (detailstr != "") {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目: "
                    &lt;&lt; detailstr
                    &lt;&lt; " あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; pImpl->m_ErrMap[0002]
                    &lt;&lt; endl;
            }
            else {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; endl;
            }
        }
        exit(1);
    }

    void Interpreter::runtimeExit(int mess_id, const char* target) {
        if (target) {
            cerr &lt;&lt; "\n動がしてるどきのまじがいだぞい。 "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; target
                &lt;&lt; " "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;

        }
        else {
            cerr &lt;&lt; "\n動がしてるどきのまじがいだぞい。 "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;

        }
        exit(1);
    }

    void Interpreter::runtimeWorning(int mess_id) {
        if (isWorningOut()) {
            cerr &lt;&lt; "\n動がしてるどきだげんんちょ、いじおう言っておぐ, "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;
        }
    }

    bool Interpreter::isWorningOut() const {
        return pImpl->m_IsWorningOut;

    }
    void Interpreter::setWorningOut(bool b) {
        pImpl->m_IsWorningOut = b;
    }

}
//end namespace ore
</pre>
</div>
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="04_02.html">戻る</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
