<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０５．ここまでの全ソース</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>proc.cpp</h3>
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include &lt;typeinfo>
#include "util.h"
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  Objectベース（インターフェイス）
    //--------------------------------------------------------------------------------------
    struct ObjeBase::Impl {
        ObjType m_ObjType;
        int m_LineNumber;
    };
    ObjeBase::ObjeBase(ObjType type) :
        pImpl(new Impl)
    {
        extern int gLine;
        pImpl->m_ObjType = type;
        pImpl->m_LineNumber = gLine;
    }
    ObjeBase::~ObjeBase() {}

    ObjType ObjeBase::getObjType()const {
        return pImpl->m_ObjType;
    }

    int ObjeBase::getLineNumber()const {
        return pImpl->m_LineNumber;
    }

    //--------------------------------------------------------------------------------------
    ///  式クラス
    //--------------------------------------------------------------------------------------
    struct Expression::Impl {
        ExpressionType m_ExpType;
    };

    Expression::Expression(ExpressionType type)
        :ObjeBase(ObjType::ExpType),
        pImpl(new Impl)
    {
        pImpl->m_ExpType = type;
    }

    Expression::~Expression() {
        delete pImpl;
    }

    ExpressionType Expression::getType()const {
        return pImpl->m_ExpType;
    }

    //--------------------------------------------------------------------------------------
    ///  boolリテラル値式クラス
    //--------------------------------------------------------------------------------------
    struct BoolLiteralExp::Impl {
        bool m_BoolValue;
    };

    BoolLiteralExp::BoolLiteralExp(bool b) :
        Expression(ExpressionType::boolLiteralExp),
        pImpl(new Impl)
    {
        pImpl->m_BoolValue = b;
    }

    BoolLiteralExp::~BoolLiteralExp() {
        delete pImpl;
    }


    bool BoolLiteralExp::getBoolValue()const {
        return pImpl->m_BoolValue;
    }

    Value BoolLiteralExp::Excute() const {
        try {
            return Value(pImpl->m_BoolValue);
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  intリテラル式クラス
    //--------------------------------------------------------------------------------------
    struct IntLiteralExp::Impl {
        int m_IntValue;
    };

    IntLiteralExp::IntLiteralExp(int i) :
        Expression(ExpressionType::intLiteralExp),
        pImpl(new Impl)
    {
        pImpl->m_IntValue = i;
    }
    IntLiteralExp::~IntLiteralExp() {
        delete pImpl;
    }

    int IntLiteralExp::getIntValue()const {
        return pImpl->m_IntValue;
    }

    Value IntLiteralExp::Excute() const {
        try {
            return Value(pImpl->m_IntValue);
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  doubleリテラル式クラス
    //--------------------------------------------------------------------------------------
    struct DoubleLiteralExp::Impl {
        double m_DoubleValue;
    };

    DoubleLiteralExp::DoubleLiteralExp(double d)
        :Expression(ExpressionType::doubleLiteralExp),
        pImpl(new Impl)
    {
        pImpl->m_DoubleValue = d;
    }

    DoubleLiteralExp::~DoubleLiteralExp() {
        delete pImpl;
    }


    double DoubleLiteralExp::getDoubleValue()const {
        return pImpl->m_DoubleValue;
    }

    Value DoubleLiteralExp::Excute() const {
        try {
            return Value(pImpl->m_DoubleValue);
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  stringリテラル式クラス
    //--------------------------------------------------------------------------------------
    struct StringLiteralExp::Impl {
        string m_StringLiteral;
    };

    StringLiteralExp::StringLiteralExp(const char* str) :
        Expression(ExpressionType::stringLiteralExp),
        pImpl(new Impl)
    {
        pImpl->m_StringLiteral = str;
    }
    StringLiteralExp::~StringLiteralExp() {
        delete pImpl;
    }

    const char* StringLiteralExp::getStringLiteral()const {
        return pImpl->m_StringLiteral.c_str();
    }

    Value StringLiteralExp::Excute() const {
        try {
            return Value(pImpl->m_StringLiteral.c_str());
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  識別子式クラス
    //--------------------------------------------------------------------------------------
    struct VariableExp::Impl {
        string m_VariableName;
    };

    VariableExp::VariableExp(const char* ident)
        :Expression(ExpressionType::variableExp),
        pImpl(new Impl)
    {
        pImpl->m_VariableName = ident;
    }

    VariableExp::~VariableExp() {
        delete pImpl;
    }

    const char* VariableExp::getIdentifier()const {
        return pImpl->m_VariableName.c_str();
    }

    Value VariableExp::Excute() const {
        try {
            return Interpreter::getInp()->getValiableValue(pImpl->m_VariableName.c_str());
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  優先式クラス
    //--------------------------------------------------------------------------------------
    struct PriorityExp::Impl {
        const Expression* m_Target;
    };

    PriorityExp::PriorityExp(const Expression* target)
        :Expression(ExpressionType::priorityExp),
        pImpl(new Impl)
    {
        pImpl->m_Target = target;
    }

    PriorityExp::~PriorityExp() {
        delete pImpl;
    }

    const Expression* PriorityExp::getTarget()const {
        return pImpl->m_Target;
    }

    Value PriorityExp::Excute() const {
        try {
            return pImpl->m_Target->Excute();
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  代入式クラス
    //--------------------------------------------------------------------------------------
    struct AssignExp::Impl {
        string m_Variable;
        const Expression* m_Operand;
    };

    AssignExp::AssignExp(const char* variable, const Expression* operand)
        :Expression(ExpressionType::assignExp),
        pImpl(new Impl)
    {
        pImpl->m_Variable = variable;
        pImpl->m_Operand = operand;
    }

    AssignExp::~AssignExp() {
        delete pImpl;
    }

    const char* AssignExp::getVariable()const {
        return pImpl->m_Variable.c_str();
    }

    const Expression* AssignExp::getOperand()const {
        return pImpl->m_Operand;
    }

    Value AssignExp::Excute() const {
        try {
            //変数の値の参照を取り出す
            Value& v = Interpreter::getInp()->getValiableValue(pImpl->m_Variable.c_str());
            //参照に代入
            v = pImpl->m_Operand->Excute();
            //それを返す
            return v;
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  追演算クラス
    //--------------------------------------------------------------------------------------
    struct ToAssExp::Impl {
        string m_Variable;
        const Expression* m_Operand;
        ExpressionType m_ExpType;
    };

    ToAssExp::ToAssExp(const char* variable, const Expression* operand, ExpressionType tp)
        :Expression(ExpressionType::assignExp),
        pImpl(new Impl)
    {
        pImpl->m_Variable = variable;
        pImpl->m_Operand = operand;
        pImpl->m_ExpType = tp;
    }

    ToAssExp::~ToAssExp() {
        delete pImpl;
    }

    const char* ToAssExp::getVariable()const {
        return pImpl->m_Variable.c_str();
    }

    const Expression* ToAssExp::getOperand()const {
        return pImpl->m_Operand;
    }

    ExpressionType ToAssExp::getExpType()const {
        return pImpl->m_ExpType;
    }

    Value ToAssExp::Excute() const {
        try {
            //変数の値の参照を取り出す
            Value& v = Interpreter::getInp()->getValiableValue(pImpl->m_Variable.c_str());
            switch (pImpl->m_ExpType) {
            case ExpressionType::addAssExp:
                //参照に追加算
                v += pImpl->m_Operand->Excute();
                break;
            case ExpressionType::subAssExp:
                //参照に追減算
                v -= pImpl->m_Operand->Excute();
                break;
            case ExpressionType::mulAssExp:
                //参照に追乗算
                v *= pImpl->m_Operand->Excute();
                break;
            case ExpressionType::divAssExp:
                //参照に追除算
                v /= pImpl->m_Operand->Excute();
                break;
            }
            //それを返す
            return v;
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  演算式クラス
    //--------------------------------------------------------------------------------------
    struct BinaryExp::Impl {
        const Expression* m_Left;
        const Expression* m_Right;
    };

    BinaryExp::BinaryExp(ExpressionType type, const Expression* left, const Expression* right)
        :Expression(type),
        pImpl(new Impl)
    {
        pImpl->m_Left = left;
        pImpl->m_Right = right;
    }

    BinaryExp::~BinaryExp() {
        delete pImpl;

    }

    const Expression* BinaryExp::getLeft()const {
        return pImpl->m_Left;
    }

    const Expression* BinaryExp::getRight()const {
        return pImpl->m_Right;
    }

    Value BinaryExp::Excute() const {
        try {
            switch (getType()) {
            case ExpressionType::addExp:
                return (pImpl->m_Left->Excute() + pImpl->m_Right->Excute());
                break;
            case ExpressionType::subExp:
                return (pImpl->m_Left->Excute() - pImpl->m_Right->Excute());
                break;
            case ExpressionType::mulExp:
                return (pImpl->m_Left->Excute() * pImpl->m_Right->Excute());
                break;
            case ExpressionType::divExp:
                return (pImpl->m_Left->Excute() / pImpl->m_Right->Excute());
                break;
            }
            Interpreter::getInp()->runtimeExit(2004, getLineNumber());
            return Value();
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  単項マイナス式クラス
    //--------------------------------------------------------------------------------------
    struct MinusExp::Impl {
        Expression* m_Target;
    };

    MinusExp::MinusExp(Expression* exp)
        :Expression(ExpressionType::minusExp),
        pImpl(new Impl)
    {
        pImpl->m_Target = exp;
    }

    MinusExp::~MinusExp() {
        delete pImpl;
    }
    const Expression* MinusExp::getTarget()const {
        return pImpl->m_Target;
    }

    //--------------------------------------------------------------------------------------
    ///  print式クラス
    //--------------------------------------------------------------------------------------
    struct PrintExp::Impl {
        const Expression* m_Target;
        bool m_Nflg;
    };

    PrintExp::PrintExp(const Expression* target, bool nflg)
        :Expression(ExpressionType::printExp),
        pImpl(new Impl)
    {
        pImpl->m_Target = target;
        pImpl->m_Nflg = nflg;
    }

    PrintExp::~PrintExp() {
        delete pImpl;
    }

    const Expression* PrintExp::getTarget()const {
        return pImpl->m_Target;
    }

    bool PrintExp::getNflg() const {
        return pImpl->m_Nflg;
    }

    Value PrintExp::Excute() const {
        try {
            auto val = pImpl->m_Target->Excute();
            switch (val.getType()) {
            case ValueType::boolVal:
                cout &lt;&lt; val.getBool();
                break;
            case ValueType::intVal:
                cout &lt;&lt; val.getInt();
                break;
            case ValueType::doubleVal:
                cout &lt;&lt; val.getDouble();
                break;
            case ValueType::stringVal:
                cout &lt;&lt; val.getString();
                break;
            case ValueType::voidVal:
                cout &lt;&lt; val.getString();
            }
            if (getNflg()) {
                cout &lt;&lt; endl;
            }
            //void型を返す
            return Value();
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  関数呼び出し式クラス
    //--------------------------------------------------------------------------------------
    struct FunctionCallExp::Impl {
        string m_Identifier;
        ArgumentList* m_Argument;
    };

    FunctionCallExp::FunctionCallExp(const char* ident, ArgumentList* args)
        :Expression(ExpressionType::functionExp),
        pImpl(new Impl)
    {
        pImpl->m_Identifier = ident;
        pImpl->m_Argument = args;
    }

    FunctionCallExp::~FunctionCallExp() {
        delete pImpl;
    }
    const char* FunctionCallExp::getIdentifier()const {
        return pImpl->m_Identifier.c_str();
    }

    //--------------------------------------------------------------------------------------
    ///  文
    //--------------------------------------------------------------------------------------
    struct Statement::Impl {
        StatementType   m_StmType;
        int m_LineNumber;
    };

    Statement::Statement(StatementType type) :
        ObjeBase(ObjType::StmType),
        pImpl(new Impl)
    {
        pImpl->m_StmType = type;
        pImpl->m_LineNumber = 0;
    }

    Statement::~Statement() {
        delete pImpl;
    }

    StatementType Statement::getType()const {
        return pImpl->m_StmType;
    }

    //--------------------------------------------------------------------------------------
    ///  式文クラス
    //--------------------------------------------------------------------------------------
    struct ExpressionStm::Impl {
        const Expression* m_Exp;
    };

    ExpressionStm::ExpressionStm(const Expression* exp)
        :Statement(StatementType::expressionStm),
        pImpl(new Impl)
    {
        pImpl->m_Exp = exp;
    }

    ExpressionStm::~ExpressionStm() {
        delete pImpl;
    }

    const Expression* ExpressionStm::getExp()const {
        return pImpl->m_Exp;
    }

    Value ExpressionStm::Excute() const {
        try {
            return getExp()->Excute();
        }
        catch (int mess_id) {
            Interpreter::getInp()->runtimeExit(mess_id, getLineNumber());
        }
        catch (...) {
            Interpreter::getInp()->runtimeExit(2002, getLineNumber());
        }
        return Value();
    }

    //--------------------------------------------------------------------------------------
    ///  Block
    //--------------------------------------------------------------------------------------
    struct Block {
        StatementList* statement_list;
    };

    //--------------------------------------------------------------------------------------
    ///  elsif
    //--------------------------------------------------------------------------------------
    struct Elsif {
        Expression  *condition;
        Block       *block;
        Elsif *next;
    };

    //--------------------------------------------------------------------------------------
    ///  if文クラス
    //--------------------------------------------------------------------------------------
    struct IfStm::Impl {
        Expression* m_Condition;
        Block* m_ThenBlock;
        Elsif* m_ElsifList;
        Block* m_ElseBlock;
    };

    IfStm::IfStm(Expression* exp)
        : Statement(StatementType::ifStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }

    IfStm::~IfStm() {
        delete pImpl;

    }

    const Expression* IfStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  while文クラス
    //--------------------------------------------------------------------------------------
    struct WhileStm::Impl {
        Expression* m_Condition;
        Block* m_Block;
    };

    WhileStm::WhileStm(Expression* exp)
        : Statement(StatementType::whileStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }

    WhileStm::~WhileStm() {
        delete pImpl;
    }

    const Expression* WhileStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  for文クラス
    //--------------------------------------------------------------------------------------
    struct ForStm::Impl {
        Expression * m_Init;
        Expression * m_Condition;
        Expression * m_Post;
        Block* m_Block;
    };

    ForStm::ForStm(Expression* exp)
        : Statement(StatementType::forStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }

    ForStm::~ForStm() {
        delete pImpl;

    }

    const Expression* ForStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  return文クラス
    //--------------------------------------------------------------------------------------
    struct ReturnStm::Impl {
        Expression * m_ReturnValue;
    };

    ReturnStm::ReturnStm(Expression* exp)
        : Statement(StatementType::returnStm),
        pImpl(new Impl)
    {
        pImpl->m_ReturnValue = exp;
    }

    ReturnStm::~ReturnStm() {
        delete pImpl;

    }

    const Expression* ReturnStm::getReturnValue()const {
        return pImpl->m_ReturnValue;
    }

    //--------------------------------------------------------------------------------------
    ///  ブロック文クラス
    //--------------------------------------------------------------------------------------
    struct BlockStm::Impl {
        StatementList * m_StatementList;
    };

    BlockStm::BlockStm(StatementList* stml)
        : Statement(StatementType::blockStm),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }

    BlockStm::BlockStm()
        : Statement(StatementType::blockStm),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = nullptr;
    }

    BlockStm::~BlockStm() {}
    const StatementList* BlockStm::getStatementList()const {
        return pImpl->m_StatementList;
    }

    //--------------------------------------------------------------------------------------
    ///  文リストクラス
    //--------------------------------------------------------------------------------------
    struct StatementList::Impl {
        const Statement* m_Statement;
        StatementList* m_Next;
    };

    StatementList::StatementList(const Statement* stm) :
        ObjeBase(ObjType::StmListType),
        pImpl(new Impl)
    {
        pImpl->m_Statement = stm;
        pImpl->m_Next = nullptr;
    }

    StatementList::~StatementList() {
        delete pImpl;
    }

    const Statement* StatementList::getStm() const {
        return pImpl->m_Statement;
    }

    StatementList* StatementList::getNext()const {
        return pImpl->m_Next;
    }

    void StatementList::setNext(StatementList* next) {
        pImpl->m_Next = next;
    }

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    struct Root::Impl {
        const StatementList* m_StatementList;
    };

    Root::Root(const StatementList* stml) :
        ObjeBase(ObjType::RootType),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }

    Root::~Root() {
        delete pImpl;
    }

    const StatementList* Root::getStmeList()const {
        return pImpl->m_StatementList;
    }

    Value Root::Excute()const {
        if (pImpl->m_StatementList) {
            auto pos = pImpl->m_StatementList;
            do {
                pos->getStm()->Excute();
                pos = pos->getNext();
            } while (pos);
        }
        else {
            Interpreter::getInp()->runtimeExit(2001, getLineNumber());
        }
        return Value();
    }

}
//end namespace ore
</pre>
</div>

</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="05_01.html">戻る</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
