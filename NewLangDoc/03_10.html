<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０３．トレース言語とインタプリタ</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０３－１０．値クラス</h3>
　この項では<b>値クラス</b>を作成します。
<h4>値クラスの作成</h4>
<b>value.h</b>を<b>oreProject</b>に追加し、以下の様な記述をします。
<div class="box1">
<pre>
#pragma once

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  値タイプ
    //--------------------------------------------------------------------------------------
    enum class ValueType {
        boolVal = 0,
        intVal,
        doubleVal,
        stringVal,
        arrayVal,
        voidVal,
        countVal
    };


    //--------------------------------------------------------------------------------------
    ///  値
    //--------------------------------------------------------------------------------------
    class Value {
    public:
        explicit Value();
        explicit Value(bool b);
        explicit Value(int i);
        explicit Value(double d);
        explicit Value(const char* s);
        Value(const Value& other);
        virtual ~Value();
        ValueType getType() const;
        bool getBool() const;
        int getInt() const;
        double getDouble() const;
        const char* getString() const;
        Value getTypedValue(ValueType t) const;
        Value& operator=(bool b);
        Value& operator=(int i);
        Value& operator=(double d);
        Value& operator=(const char* s);
        Value& operator=(const Value& other);
        Value operator+(const Value& other);
        Value operator-(const Value& other);
        Value operator*(const Value& other);
        Value operator/(const Value& other);
        Value operator%(const Value& other);
        Value operator&(const Value& other);
        Value& operator+=(const Value& other);
        Value& operator-=(const Value& other);
        Value& operator*=(const Value& other);
        Value& operator/=(const Value& other);
        Value& operator&=(const Value& other);
        bool operator == (const Value& other);
        bool operator != (const Value& other);
        bool operator &lt; (const Value& other);
        bool operator > (const Value& other);
        bool operator &lt;= (const Value& other);
        bool operator >= (const Value& other);
        bool operator && (const Value& other);
        bool operator || (const Value& other);
        //配列用
        void setArrClear();
        bool isArrKey(size_t index)const;
        bool isArrKey(const char* key)const;
        void createArrKey(size_t index);
        void createArrKey(const char* key);
        size_t getNextIndexKey() const;
        const Value& operator[](size_t index)const;
        Value& operator[](size_t index);
        const Value& operator[](const char* key)const;
        Value& operator[](const char* key);
        size_t getArrCount() const;
        const Value& getArrVValue(size_t index) const;
        Value& getArrVValue(size_t index);
        Value getArrVKey(size_t index) const;
    private:
        <span class="red">// pImplイディオム
        struct Impl;
        Impl* pImpl;</span>
    };

}
//end namespace ore
</pre>
</div>
　赤くなっているところが<b>Implイディオム</b>です。ヘッダ側からは、単純な構造体宣言でしかありません。<br />
　続いて<b>proc.h</b>に今作った<b>value.h</b>をインクルードします。以下、<b>proc.h</b>です。
<div class="box1">
<pre>
#pragma once

<span class="red">#include "value.h"</span>
#include "interpreter.h"

namespace ore {

//中略

}
//end namespace ore
</pre>
</div>
　続いて<b>value.cpp</b>です。<b>oreProject</b>に新規に追加し、以下を記述します。
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;cmath>
#include &lt;cfenv>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include &lt;typeinfo>
#include "util.h"
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  暗黙の型キャスト
    //--------------------------------------------------------------------------------------
    inline bool toBoolValue() {
        return false;
    }
    inline bool toBoolValue(bool b) {
        return b;
    }
    inline bool toBoolValue(int i) {
        if (i != 0) {
            return true;
        }
        else {
            return false;
        }
    }
    inline bool toBoolValue(double b) {
        if (b != 0.0) {
            return true;
        }
        else {
            return false;
        }
    }
    inline bool toBoolValue(const string& str) {
        //必ず10進数に変換
        int i;
        try {
            i = std::stoi(str, nullptr, 10);
        }
        catch (...) {
            i = 0;
        }
        if (i != 0) {
            return true;
        }
        else {
            return false;
        }
    }

    inline int toIntValue() {
        return 0;
    }

    inline int toIntValue(bool b) {
        if (b != false) {
            return 1;
        }
        else {
            return 0;
        }
    }

    inline int toIntValue(int i) {
        return i;
    }

    inline int toIntValue(double d) {
        //強制的な型返還
        int i = (int)d;
        return i;
    }

    inline int toIntValue(const string& str) {
        //必ず10進数に変換
        int i;
        try {
            i = std::stoi(str, nullptr, 10);
        }
        catch (...) {
            i = 0;
        }
        return i;
    }

    inline double toDoubleValue() {
        return 0.0;
    }

    inline double toDoubleValue(bool b) {
        if (b) {
            return 1.0;
        }
        else {
            return 0.0;
        }
    }

    inline double toDoubleValue(int i) {
        //C++に合わせた型返還
        double d = i;
        return d;
    }

    inline double toDoubleValue(double d) {
        return d;
    }

    inline double toDoubleValue(const string& str) {
        //10進のdoubleに変換
        double d;
        try {
            d = std::stod(str);
        }
        catch (...) {
            d = 0.0;
        }
        return d;
    }

    inline string toStringValue() {
        return string("");
    }

    inline string toStringValue(bool b) {
        if (b) {
            return string("1");
        }
        else {
            return string("");
        }
    }

    inline string toStringValue(int i) {
        string str = std::to_string(i);
        return str;
    }

    inline string toStringValue(double d) {
        string str = std::to_string(d);
        return str;
    }

    inline string toStringValue(const string& str) {
        return str;
    }


    //--------------------------------------------------------------------------------------
    ///  配列
    //--------------------------------------------------------------------------------------
    struct ArrItem {
        size_t sztKey;
        string strKey;
        bool isKeyStr;
        Value val;
        ArrItem() :
            sztKey(0), strKey(), isKeyStr(false)
        {}
    };

    //--------------------------------------------------------------------------------------
    ///  値
    //--------------------------------------------------------------------------------------
    struct Value::Impl {
        ValueType m_Type;
        string strV;
        vector&lt;shared_ptr&lt;ArrItem>> arrV;
        //get用のstring
        string tmpStr;
        union {
            bool boolV;
            int intV;
            double doubleV;
        };
    };

    Value::Value() :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::voidVal;
        pImpl->intV = 0;
    }

    Value::Value(bool b) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::boolVal;
        pImpl->boolV = b;
    }

    Value::Value(int i) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::intVal;
        pImpl->intV = i;
    }

    Value::Value(double d) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::doubleVal;
        pImpl->doubleV = d;
    }

    Value::Value(const char* s) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::stringVal;
        pImpl->strV = s;
    }

    Value::Value(const Value& other) :
        pImpl(new Impl)
    {
        *pImpl = *(other.pImpl);
    }

    Value& Value::operator=(bool b) {
        pImpl->arrV.clear();
        pImpl->m_Type = ValueType::boolVal;
        pImpl->boolV = b;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(int i) {
        pImpl->arrV.clear();
        pImpl->m_Type = ValueType::intVal;
        pImpl->intV = i;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(double d) {
        pImpl->arrV.clear();
        pImpl->m_Type = ValueType::doubleVal;
        pImpl->doubleV = d;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(const char* s) {
        pImpl->arrV.clear();
        pImpl->m_Type = ValueType::stringVal;
        pImpl->intV = 0;
        pImpl->strV = s;
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(const Value& other) {
        *pImpl = *(other.pImpl);
        return *this;
    }

    Value::~Value() {
        delete pImpl;
        pImpl = nullptr;
    }

    ValueType Value::getType() const {
        return pImpl->m_Type;
    }

    bool Value::getBool() const {
        switch (getType())
        {
        case ValueType::boolVal:
            return pImpl->boolV;
            break;
        case ValueType::intVal:
            return toBoolValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            return toBoolValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            return toBoolValue(pImpl->strV);
            break;
        case ValueType::arrayVal:
            Interpreter::getInp()->runtimeExit(2021);
            break;
        }
        return toBoolValue();
    }

    int Value::getInt() const {
        switch (getType()) {
        case ValueType::boolVal:
            return toIntValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            return pImpl->intV;
            break;
        case ValueType::doubleVal:
            return toIntValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            return toIntValue(pImpl->strV);
            break;
        case ValueType::arrayVal:
            Interpreter::getInp()->runtimeExit(2021);
            break;
        }
        return toIntValue();
    }

    double Value::getDouble() const {
        switch (getType()) {
        case ValueType::boolVal:
            return toDoubleValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            return toDoubleValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            return pImpl->doubleV;
            break;
        case ValueType::stringVal:
            return toDoubleValue(pImpl->strV);
            break;
        case ValueType::arrayVal:
            Interpreter::getInp()->runtimeExit(2021);
            break;
        }
        return toDoubleValue();
    }

    const char* Value::getString() const {
        switch (getType()) {
        case ValueType::boolVal:
            pImpl->tmpStr = toStringValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            pImpl->tmpStr = toStringValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            pImpl->tmpStr = toStringValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            pImpl->tmpStr = pImpl->strV;
            break;
        case ValueType::arrayVal:
            Interpreter::getInp()->runtimeExit(2021);
            break;
        default:
            pImpl->tmpStr = toStringValue();
            break;
        }
        return pImpl->tmpStr.c_str();
    }

    Value Value::getTypedValue(ValueType t) const {
        Value val;
        switch (t) {
        case ValueType::boolVal:
            val = getBool();
            break;
        case ValueType::intVal:
            val = getInt();
            break;
        case ValueType::doubleVal:
            val = getDouble();
            break;
        case ValueType::stringVal:
            val = getString();
            break;
        case ValueType::arrayVal:
            Interpreter::getInp()->runtimeExit(2021);
            break;
        default:
            break;
        }
        return val;
    }


    Value getOptimalTypeValue(double ret) {
        double mod = std::fmod(ret, 1.0);
        Value eps = Interpreter::getInp()->getConfig("calc_epsilon");
        double epsd = eps.getDouble();
        if (abs(epsd) >= 0.1)epsd = 0.1;
        if (std::fabs(mod) &lt;= epsd) {
            return Value((int)ret);
        }
        return Value(ret);
    }

    Value Value::operator+(const Value& other) {
        double ret((*this).getDouble());
        ret += other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator-(const Value& other) {
        double ret((*this).getDouble());
        ret -= other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator*(const Value& other) {
        double ret((*this).getDouble());
        ret *= other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator/(const Value& other) {
        double other_double = other.getDouble();
        if (other_double == 0.0) {
            Interpreter::getInp()->runtimeExit(2003);
        }
        double ret((*this).getDouble());
        ret /= other_double;
        return getOptimalTypeValue(ret);
    }

    Value Value::operator%(const Value& other) {
        double other_double = other.getDouble();
        if (other_double == 0.0) {
            Interpreter::getInp()->runtimeExit(2003);
        }
        double ret((*this).getDouble());
        ret = fmod(ret, other_double);
        return getOptimalTypeValue(ret);
    }


    Value Value::operator&(const Value& other) {
        string ret((*this).getString());
        ret += other.getString();
        return Value(ret.c_str());
    }

    Value&  Value::operator&=(const Value& other) {
        *this = *this & other;
        return *this;
    }

    Value& Value::operator+=(const Value& other) {
        *this = *this + other;
        return *this;
    }

    Value& Value::operator-=(const Value& other) {
        *this = *this - other;
        return *this;

    }

    Value& Value::operator*=(const Value& other) {
        *this = *this * other;
        return *this;
    }

    Value& Value::operator/=(const Value& other) {
        *this = *this / other;
        return *this;
    }

    bool  Value::operator == (const Value& other) {
        if (this->getType() == ValueType::stringVal
            && other.getType() == ValueType::stringVal) {
            return (pImpl->strV == other.pImpl->strV);
        }
        if (this->getType() == ValueType::doubleVal
            || other.getType() == ValueType::doubleVal) {
            double left((*this).getDouble());
            double right(other.getDouble());
            return (left == right);
        }
        else if (this->getType() == ValueType::intVal
            || other.getType() == ValueType::intVal) {
            int left((*this).getInt());
            int right(other.getInt());
            return (left == right);
        }
        else if (this->getType() == ValueType::boolVal
            || other.getType() == ValueType::boolVal) {
            bool left((*this).getBool());
            bool right(other.getBool());
            return (left == right);
        }
        else {
            return false;
        }
    }

    bool  Value::operator != (const Value& other) {
        return !((*this) == other);
    }

    bool Value::operator &lt; (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left &lt; right);
    }

    bool Value::operator > (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left > right);
    }

    bool Value::operator &lt;= (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left &lt;= right);
    }

    bool Value::operator >= (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left >= right);
    }

    bool Value::operator && (const Value& other) {
        bool left((*this).getBool());
        bool right(other.getBool());
        return (left && right);
    }

    bool Value::operator || (const Value& other) {
        bool left((*this).getBool());
        bool right(other.getBool());
        return (left || right);
    }

    void Value::setArrClear() {
        pImpl->arrV.clear();
        pImpl->m_Type = ValueType::arrayVal;
    }

    bool Value::isArrKey(size_t index)const {
        if (pImpl->m_Type != ValueType::arrayVal) {
            return false;
        }
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr == false && v->sztKey == index) {
                return true;
            }
        }
        return false;
    }

    bool Value::isArrKey(const char* key)const {
        if (pImpl->m_Type != ValueType::arrayVal) {
            return false;
        }
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr && v->strKey == key) {
                return true;
            }
        }
        return false;
    }

    void Value::createArrKey(size_t index) {
        pImpl->m_Type = ValueType::arrayVal;
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = false;
        ptrArrItem->sztKey = index;
        ptrArrItem->val = Value();
        size_t size = pImpl->arrV.size();
        pImpl->arrV.push_back(ptrArrItem);
    }

    void Value::createArrKey(const char* key) {
        pImpl->m_Type = ValueType::arrayVal;
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = true;
        ptrArrItem->strKey = key;
        ptrArrItem->val = Value("");
        size_t size = pImpl->arrV.size();
        pImpl->arrV.push_back(ptrArrItem);
    }

    size_t Value::getNextIndexKey() const {
        int lastIndex = -1;
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr == false) {
                if (((int)v->sztKey) > lastIndex) {
                    lastIndex = (int)v->sztKey;
                }
            }
        }
        return (size_t)(lastIndex + 1);
    }



    const Value& Value::operator[](size_t index)const {
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr == false && v->sztKey == index) {
                return v->val;
            }
        }
        //無かった
        //ワーニングを出す
        Interpreter::getInp()->runtimeWorning(2022);
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = false;
        ptrArrItem->sztKey = index;
        ptrArrItem->val = Value();
        size_t size = pImpl->arrV.size();
        pImpl->m_Type = ValueType::arrayVal;
        pImpl->arrV.push_back(ptrArrItem);
        return pImpl->arrV[size]->val;
    }
    Value& Value::operator[](size_t index) {
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr == false && v->sztKey == index) {
                return v->val;
            }
        }
        //無かった
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = false;
        ptrArrItem->sztKey = index;
        ptrArrItem->val = Value();
        size_t size = pImpl->arrV.size();
        pImpl->m_Type = ValueType::arrayVal;
        pImpl->arrV.push_back(ptrArrItem);
        return pImpl->arrV[size]->val;
    }

    const Value& Value::operator[](const char* key)const {
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr && v->strKey == key) {
                return v->val;
            }
        }
        //無かった
        //ワーニングを出す
        Interpreter::getInp()->runtimeWorning(2022);
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = true;
        ptrArrItem->strKey = key;
        ptrArrItem->val = Value("");
        size_t size = pImpl->arrV.size();
        pImpl->m_Type = ValueType::arrayVal;
        pImpl->arrV.push_back(ptrArrItem);
        return pImpl->arrV[size]->val;

    }
    Value& Value::operator[](const char* key) {
        for (auto& v : pImpl->arrV) {
            if (v->isKeyStr && v->strKey == key) {
                return v->val;
            }
        }
        //無かった
        auto ptrArrItem = make_shared&lt;ArrItem>();
        ptrArrItem->isKeyStr = true;
        ptrArrItem->strKey = key;
        ptrArrItem->val = Value("");
        size_t size = pImpl->arrV.size();
        pImpl->m_Type = ValueType::arrayVal;
        pImpl->arrV.push_back(ptrArrItem);
        return pImpl->arrV[size]->val;
    }

    size_t Value::getArrCount() const {
        return pImpl->arrV.size();
    }

    const Value& Value::getArrVValue(size_t index) const {
        return pImpl->arrV[index]->val;
    }
    Value& Value::getArrVValue(size_t index) {
        return pImpl->arrV[index]->val;
    }

    Value Value::getArrVKey(size_t index) const {
        Value ret;
        if (pImpl->arrV[index]->isKeyStr) {
            ret = pImpl->arrV[index]->strKey.c_str();
        }
        else {
            ret = (int)pImpl->arrV[index]->sztKey;
        }
        return ret;
    }

}
//end namespace ore
</pre>
</div>
　ここでは演算子の多重定義など、Value型が持っていると便利であろう機能を実装しています。<br />
　まず、冒頭から実装されている
<div class="box1">
<pre>
    inline bool toBoolValue() {
        return false;
    }
    inline bool toBoolValue(bool b) {
        return b;
    }
    inline bool toBoolValue(int i) {
        if (i != 0) {
            return true;
        }
        else {
            return false;
        }
    }
//以下略
</pre>
</div>
　があります。これらの関数は呼ばれたときに、可能であれば<b>インライン展開</b>します。グローバルな関数として実装しています。<br />
　続いて配列表現の形の宣言があり、続いて<b>Implイディオム</b>の宣言があります。
<div class="box1">
<pre>
    struct Value::Impl {
        ValueType m_Type;
        string strV;
        vector&lt;shared_ptr&lt;ArrItem>> arrV;
        //get用のstring
        string tmpStr;
        union {
            bool boolV;
            int intV;
            double doubleV;
        };
    };
</pre>
</div>
　<b>Value::Impl構造体</b>はヘッダ部にプライベート変数としてポインタが宣言されています。<br />
　ですので<b>Valueクラスの各コンストラクタ</b>で初期化します。以下の様な感じです。
<div class="box1">
<pre>
    Value::Value(double d) :
        <span class="red">pImpl(new Impl)</span>
    {
        pImpl->m_Type = ValueType::doubleVal;
        pImpl->doubleV = d;
    }
</pre>
</div>
　この例は<b>double型</b>で初期化されたときの実装です。赤くなっているように、メンバイニシャライザで<b>pImpl</b>に<b>new</b>で初期化します。<b>コンストラクタ</b>の中身で、<b>pImpl</b>に値を設定します。<br />
　<b>Valueクラス</b>の<b>デストラクタ</b>で、<b>pImpl</b>を開放します。
<div class="box1">
<pre>
    Value::~Value() {
        delete pImpl;
        pImpl = nullptr;
    }
</pre>
</div>
　ここで<b>pImpl = nullptr;</b>の記述は本当は必要がないのですが、<b>後始末</b>を明確にするために記述してあります。<br />
　このように初期化と開放をしっかり記述しておけば、あとは、<b>演算子の多重定義</b>を細かく記述すことで、<b>Value型同士の演算</b>が実装しやすくなります。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="03_09.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="03_11.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
