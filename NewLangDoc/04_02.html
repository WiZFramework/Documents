<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2018年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０４．インタプリタの作成</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０４－０２．最初のソース</h3>
　まず<b>oreProject</b>の<b>ソースファイル</b>を<b>右クリック</b>し<b>追加－新しい項目</b>で<b>Interpreter.cpp</b>という<b>cppファイル</b>を作成しておきます。<br />
　そのうえで、各ファイルを以下のように書き換えます。まず<b>oreProject</b>側の<b>proc.h</b>です。
<h4>proc.hの書き換え</h4>
<div class="box1">
<pre>
#pragma once

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  オブジェクトタイプ
    //--------------------------------------------------------------------------------------
    enum class ObjType {
        NullType,
        ExpType,
        StmType,
        StmListType,
        BlockType,
        RootType,
        expTypeCount
    };

    //--------------------------------------------------------------------------------------
    ///  Objectベース（インターフェイス）
    //--------------------------------------------------------------------------------------
    class ObjeBase {
    protected:
        ObjeBase(ObjType type);
    public:
        virtual ~ObjeBase();
        ObjType getObjType()const;
        virtual void Excute() const{}
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  式タイプ
    //--------------------------------------------------------------------------------------
    enum class ExpressionType{
        nullExp,
        boolExp,
        intExp,
        doubleExp,
        stringExp,
        identifierExp,
        assignExp,
        addExp,
        subExp,
        mulExp,
        divExp,
        modExp,
        logicalAndExp,
        logicalOrExp,
        eqExp,
        neExp,
        gtExp,
        geExp,
        ltExp,
        leExp,
        minusExp,
        functionExp,
        expTypeCount
    };


    //--------------------------------------------------------------------------------------
    ///  式クラス
    //--------------------------------------------------------------------------------------
    class Expression : public ObjeBase {
    protected:
        Expression(ExpressionType type);
    public:
        virtual ~Expression();
        ExpressionType getType()const;
        void setLineNumber(int i);
        int getLineNumber()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };


    //--------------------------------------------------------------------------------------
    ///  bool値式クラス
    //--------------------------------------------------------------------------------------
    class BoolValueExp : public Expression {
    public:
        BoolValueExp();
        virtual ~BoolValueExp();
        void setBoolValue(bool b);
        bool getBoolValue()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };


    //--------------------------------------------------------------------------------------
    ///  int値式クラス
    //--------------------------------------------------------------------------------------
    class IntValueExp : public Expression {
    public:
        IntValueExp();
        virtual ~IntValueExp();
        void setIntValue(int i);
        int getIntValue()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  double値式クラス
    //--------------------------------------------------------------------------------------
    class DoubleValueExp : public Expression {
    public:
        DoubleValueExp();
        virtual ~DoubleValueExp();
        void setDoubleValue(double d);
        double getDoubleValue()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  string値式クラス
    //--------------------------------------------------------------------------------------
    class StringValueExp : public Expression {
    public:
        StringValueExp();
        virtual ~StringValueExp();
        void setStringValue(const char* str);
        const char* getStringValue()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  識別子式クラス
    //--------------------------------------------------------------------------------------
    class IdentifierExp : public Expression {
    public:
        IdentifierExp(const char* ptr);
        virtual ~IdentifierExp();
        const char* getIdentifier()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };


    //--------------------------------------------------------------------------------------
    ///  代入式クラス
    //--------------------------------------------------------------------------------------
    class AssignExp : public Expression {
    public:
        AssignExp(const char* variable, Expression* operand);
        virtual ~AssignExp();
        const char* getVariable()const;
        const Expression* getOperand()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  演算式クラス
    //--------------------------------------------------------------------------------------
    class BinaryExp : public Expression {
    public:
        BinaryExp(ExpressionType type, Expression* left, Expression* right);
        virtual ~BinaryExp();
        const Expression* getLeft()const;
        const Expression* getRight()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  単項マイナス式クラス
    //--------------------------------------------------------------------------------------
    class MinusExp : public Expression {
    public:
        MinusExp(Expression* exp);
        virtual ~MinusExp();
        const Expression* getExp()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    /// 引数構造体
    //--------------------------------------------------------------------------------------
    struct ArgumentList {
        Expression *expression;
        ArgumentList *next;
    };

    //--------------------------------------------------------------------------------------
    ///  関数呼び出し式クラス
    //--------------------------------------------------------------------------------------
    class FunctionCallExp : public Expression {
    public:
        FunctionCallExp(const char* ident, ArgumentList* args);
        virtual ~FunctionCallExp();
        const char* getIdentifier()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };


    //--------------------------------------------------------------------------------------
    ///  文タイプ
    //--------------------------------------------------------------------------------------
    enum class StatementType {
        nullStm,
        expressionStm,
        blockStm,
        printStm,
        ifStm,
        whileStm,
        forStm,
        returnStm,
        breakStm,
        continueStm,
        stmTypeCount
    };


    //--------------------------------------------------------------------------------------
    ///  文
    //--------------------------------------------------------------------------------------
    class Statement : public ObjeBase {
    protected:
        Statement(StatementType type);
    public:
        virtual ~Statement();
        StatementType getType()const;
        void setLineNumber(int i);
        int getLineNumber()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  式文クラス
    //--------------------------------------------------------------------------------------
    class ExpressionStm : public Statement {
    public:
        ExpressionStm(const Expression* exp);
        virtual ~ExpressionStm();
        const Expression* getExp()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  print文クラス
    //--------------------------------------------------------------------------------------
    class PrintStm : public Statement {
    public:
        PrintStm(const Expression* exp,bool nflg);
        virtual ~PrintStm();
        const Expression* getExp()const;
        bool getNflg() const;
        virtual void Excute()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };


    //--------------------------------------------------------------------------------------
    ///  if文クラス
    //--------------------------------------------------------------------------------------
    class IfStm : public Statement {
    public:
        IfStm(Expression* exp);
        virtual ~IfStm();
        const Expression* getCondition()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  while文クラス
    //--------------------------------------------------------------------------------------
    class WhileStm : public Statement {
    public:
        WhileStm(Expression* exp);
        virtual ~WhileStm();
        const Expression* getCondition()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  for文クラス
    //--------------------------------------------------------------------------------------
    class ForStm : public Statement {
    public:
        ForStm(Expression* exp);
        virtual ~ForStm();
        const Expression* getCondition()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  return文クラス
    //--------------------------------------------------------------------------------------
    class ReturnStm : public Statement {
    public:
        ReturnStm(Expression* exp);
        virtual ~ReturnStm();
        const Expression* getReturnValue()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    class StatementList;
    //--------------------------------------------------------------------------------------
    ///  ブロック文クラス
    //--------------------------------------------------------------------------------------
    class BlockStm : public Statement {
    public:
        BlockStm(StatementList* stml);
        BlockStm();
        virtual ~BlockStm();
        const StatementList* getStatementList()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  文リストクラス
    //--------------------------------------------------------------------------------------
    class StatementList : public ObjeBase {
    public:
        StatementList(const Statement* stm);
        virtual ~StatementList();
        const Statement* getStm() const;
        StatementList* getNext()const;
        void setNext(StatementList* next);
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    class Root : public ObjeBase {
    public:
        Root(const StatementList* stml);
        virtual ~Root();
        virtual void Excute()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  インタープリタクラス
    //--------------------------------------------------------------------------------------
    class Interpreter {
        Interpreter();
    public:
        ~Interpreter();
        int Compile(FILE *fp);
        void Exec();
        void Delete();
        ///Util
        const char* createFixedString(const char* ext);
        ///Expression
        Expression* createIdentifierExp(const char* ext);
        Expression* createDoubleValueExp(const char* ext);
        ///Statement
        Statement* createExpressionStm(const Expression* exp);
        Statement* createBlockStm();
        Statement* createBlockStm(StatementList* stml);
        Statement* createPrintStm(const Expression* exp,bool nflg);
        ///StatementList
        StatementList* createStatementList(const Statement* stm);
        StatementList* createStatementList(StatementList* stml,const Statement* stm);
        //Root
        Root*  createRoot(const StatementList* stml);

        static Interpreter* getInp();
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

}
//end namespace ore
</pre>
</div>
<h4>proc.cppの書き換え</h4>
　続いて<b>proc.cpp</b>です。
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  Objectベース（インターフェイス）
    //--------------------------------------------------------------------------------------
    struct ObjeBase::Impl {
        ObjType m_ObjType;
    };
    ObjeBase::ObjeBase(ObjType type):
        pImpl(new Impl)
    {
        pImpl->m_ObjType = type;
    }
    ObjeBase::~ObjeBase() {}

    ObjType ObjeBase::getObjType()const {
        return pImpl->m_ObjType;
    }

    //--------------------------------------------------------------------------------------
    ///  式クラス
    //--------------------------------------------------------------------------------------
    struct Expression::Impl {
        ExpressionType m_ExpType;
        int m_LineNumber;
    };

    Expression::Expression(ExpressionType type)
        :ObjeBase(ObjType::ExpType),
        pImpl(new Impl)
    {
        pImpl->m_ExpType = type;
        pImpl->m_LineNumber = 0;
    }

    Expression::~Expression() {
        delete pImpl;
    }

    ExpressionType Expression::getType()const {
        return pImpl->m_ExpType;
    }
    void Expression::setLineNumber(int i) {
        pImpl->m_LineNumber = i;
    }
    int Expression::getLineNumber()const {
        return pImpl->m_LineNumber;
    }

    //--------------------------------------------------------------------------------------
    ///  bool値式クラス
    //--------------------------------------------------------------------------------------
    struct BoolValueExp::Impl {
        bool m_BoolValue;
    };

    BoolValueExp::BoolValueExp() :
        Expression(ExpressionType::boolExp),
        pImpl(new Impl)
    {
        pImpl->m_BoolValue = false;
    }

    BoolValueExp::~BoolValueExp() {
        delete pImpl;
    }

    void BoolValueExp::setBoolValue(bool b) {
        pImpl->m_BoolValue = b;
    }
    bool BoolValueExp::getBoolValue()const {
        return pImpl->m_BoolValue;
    }

    //--------------------------------------------------------------------------------------
    ///  int値式クラス
    //--------------------------------------------------------------------------------------
    struct IntValueExp::Impl {
        int m_IntValue;
    };

    IntValueExp::IntValueExp() :
        Expression(ExpressionType::intExp),
        pImpl(new Impl)
    {
        pImpl->m_IntValue = 0;
    }
    IntValueExp::~IntValueExp() {
        delete pImpl;
    }

    void IntValueExp::setIntValue(int i) {
        pImpl->m_IntValue = i;
    }
    int IntValueExp::getIntValue()const {
        return pImpl->m_IntValue;
    }

    //--------------------------------------------------------------------------------------
    ///  double値式クラス
    //--------------------------------------------------------------------------------------
    struct DoubleValueExp::Impl {
        double m_DoubleValue;
    };

    DoubleValueExp::DoubleValueExp() 
        :Expression(ExpressionType::doubleExp),
        pImpl(new Impl)
    {
        pImpl->m_DoubleValue = 0.0;
    }
    DoubleValueExp::~DoubleValueExp() {
        delete pImpl;
    }
    void DoubleValueExp::setDoubleValue(double d) {
        pImpl->m_DoubleValue = d;
    }
    double DoubleValueExp::getDoubleValue()const {
        return pImpl->m_DoubleValue;
    }

    //--------------------------------------------------------------------------------------
    ///  string値式クラス
    //--------------------------------------------------------------------------------------
    struct StringValueExp::Impl {
        string m_StringValue;
    };

    StringValueExp::StringValueExp() :
        Expression(ExpressionType::stringExp),
        pImpl(new Impl)
    {
        pImpl->m_StringValue = "";
    }
    StringValueExp::~StringValueExp() {
        delete pImpl;
    }

    void StringValueExp::setStringValue(const char* str) {
        pImpl->m_StringValue = str;
    }
    const char* StringValueExp::getStringValue()const {
        return pImpl->m_StringValue.c_str();
    }

    //--------------------------------------------------------------------------------------
    ///  識別子式クラス
    //--------------------------------------------------------------------------------------
    struct IdentifierExp::Impl {
        const char* m_Identifier;
    };

    IdentifierExp::IdentifierExp(const char* ptr)
        :Expression(ExpressionType::identifierExp),
        pImpl(new Impl)
    {
        pImpl->m_Identifier = ptr;
    }
    IdentifierExp::~IdentifierExp() {
        delete pImpl;
    }
    const char* IdentifierExp::getIdentifier()const {
        return pImpl->m_Identifier;
    }

    //--------------------------------------------------------------------------------------
    ///  代入式クラス
    //--------------------------------------------------------------------------------------
    struct AssignExp::Impl {
        string m_Variable;
        Expression* m_Operand;
    };

    AssignExp::AssignExp(const char* variable, Expression* operand)
        :Expression(ExpressionType::assignExp),
        pImpl(new Impl)
    {
        pImpl->m_Variable = variable;
        pImpl->m_Operand = operand;
    }
    AssignExp::~AssignExp() {
        delete pImpl;
    }
    const char* AssignExp::getVariable()const {
        return pImpl->m_Variable.c_str();
    }
    const Expression* AssignExp::getOperand()const {
        return pImpl->m_Operand;
    }

    //--------------------------------------------------------------------------------------
    ///  演算式クラス
    //--------------------------------------------------------------------------------------
    struct BinaryExp::Impl {
        Expression* m_Left;
        Expression* m_Right;
    };

    BinaryExp::BinaryExp(ExpressionType type, Expression* left, Expression* right)
        :Expression(type),
        pImpl(new Impl)
    {
        pImpl->m_Left = left;
        pImpl->m_Right = right;
    }
    BinaryExp::~BinaryExp() {
        delete pImpl;

    }
    const Expression* BinaryExp::getLeft()const {
        return pImpl->m_Left;
    }
    const Expression* BinaryExp::getRight()const {
        return pImpl->m_Right;
    }

    //--------------------------------------------------------------------------------------
    ///  単項マイナス式クラス
    //--------------------------------------------------------------------------------------
    struct MinusExp::Impl {
        Expression* m_Exp;
    };

    MinusExp::MinusExp(Expression* exp)
        :Expression(ExpressionType::minusExp),
        pImpl(new Impl)
    {
        pImpl->m_Exp = exp;
    }
    MinusExp::~MinusExp() {
        delete pImpl;
    }
    const Expression* MinusExp::getExp()const {
        return pImpl->m_Exp;
    }

    //--------------------------------------------------------------------------------------
    ///  関数呼び出し式クラス
    //--------------------------------------------------------------------------------------
    struct FunctionCallExp::Impl {
        string m_Identifier;
        ArgumentList* m_Argument;
    };

    FunctionCallExp::FunctionCallExp(const char* ident, ArgumentList* args)
        :Expression(ExpressionType::functionExp),
        pImpl(new Impl)
    {
        pImpl->m_Identifier = ident;
        pImpl->m_Argument = args;
    }
    FunctionCallExp::~FunctionCallExp() {
        delete pImpl;
    }
    const char* FunctionCallExp::getIdentifier()const {
        return pImpl->m_Identifier.c_str();
    }

    //--------------------------------------------------------------------------------------
    ///  文
    //--------------------------------------------------------------------------------------
    struct Statement::Impl {
        StatementType   m_StmType;
        int m_LineNumber;
    };

    Statement::Statement(StatementType type) :
        ObjeBase(ObjType::StmType),
        pImpl(new Impl)
    {
        pImpl->m_StmType = type;
        pImpl->m_LineNumber = 0;
    }
    Statement::~Statement() {
        delete pImpl;
    }
    StatementType Statement::getType()const {
        return pImpl->m_StmType;
    }
    void Statement::setLineNumber(int i) {
        pImpl->m_LineNumber = i;
    }
    int Statement::getLineNumber()const {
        return pImpl->m_LineNumber;
    }

    //--------------------------------------------------------------------------------------
    ///  式文クラス
    //--------------------------------------------------------------------------------------
    struct ExpressionStm::Impl {
        const Expression* m_Exp;
    };

    ExpressionStm::ExpressionStm(const Expression* exp)
        :Statement(StatementType::expressionStm),
        pImpl(new Impl)
    {
        pImpl->m_Exp = exp;
    }
    ExpressionStm::~ExpressionStm() {
        delete pImpl;
    }
    const Expression* ExpressionStm::getExp()const {
        return pImpl->m_Exp;
    }

    //--------------------------------------------------------------------------------------
    ///  print文クラス
    //--------------------------------------------------------------------------------------
    struct PrintStm::Impl {
        const Expression* m_Exp;
        bool m_Nflg;
    };

    PrintStm::PrintStm(const Expression* exp,bool nflg)
        :Statement(StatementType::printStm),
        pImpl(new Impl)
    {
        pImpl->m_Exp = exp;
        pImpl->m_Nflg = nflg;
    }

    PrintStm::~PrintStm(){
        delete pImpl;
    }

    const Expression* PrintStm::getExp()const{
        return pImpl->m_Exp;
    }

    bool PrintStm::getNflg() const {
        return pImpl->m_Nflg;
    }

    void PrintStm::Excute()const {

    }


    //--------------------------------------------------------------------------------------
    ///  Block
    //--------------------------------------------------------------------------------------
    struct Block {
        StatementList* statement_list;
    };

    //--------------------------------------------------------------------------------------
    ///  elsif
    //--------------------------------------------------------------------------------------
    struct Elsif {
        Expression  *condition;
        Block       *block;
        Elsif *next;
    };

    //--------------------------------------------------------------------------------------
    ///  if文クラス
    //--------------------------------------------------------------------------------------
    struct IfStm::Impl {
        Expression* m_Condition;
        Block* m_ThenBlock;
        Elsif* m_ElsifList;
        Block* m_ElseBlock;
    };

    IfStm::IfStm(Expression* exp) 
        : Statement(StatementType::ifStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }
    IfStm::~IfStm() {
        delete pImpl;

    }
    const Expression* IfStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  while文クラス
    //--------------------------------------------------------------------------------------
    struct WhileStm::Impl {
        Expression* m_Condition;
        Block* m_Block;
    };

    WhileStm::WhileStm(Expression* exp)
        : Statement(StatementType::whileStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }
    WhileStm::~WhileStm() {
        delete pImpl;
    }
    const Expression* WhileStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  for文クラス
    //--------------------------------------------------------------------------------------
    struct ForStm::Impl {
        Expression * m_Init;
        Expression * m_Condition;
        Expression * m_Post;
        Block* m_Block;
    };
    ForStm::ForStm(Expression* exp)
        : Statement(StatementType::forStm),
        pImpl(new Impl)
    {
        pImpl->m_Condition = exp;
    }

    ForStm::~ForStm() {
        delete pImpl;

    }
    const Expression* ForStm::getCondition()const {
        return pImpl->m_Condition;
    }

    //--------------------------------------------------------------------------------------
    ///  return文クラス
    //--------------------------------------------------------------------------------------
    struct ReturnStm::Impl {
        Expression * m_ReturnValue;
    };
    ReturnStm::ReturnStm(Expression* exp)
        : Statement(StatementType::returnStm),
        pImpl(new Impl)
    {
        pImpl->m_ReturnValue = exp;
    }
    ReturnStm::~ReturnStm() {
        delete pImpl;

    }
    const Expression* ReturnStm::getReturnValue()const {
        return pImpl->m_ReturnValue;
    }

    //--------------------------------------------------------------------------------------
    ///  ブロック文クラス
    //--------------------------------------------------------------------------------------
    struct BlockStm::Impl {
        StatementList * m_StatementList;
    };

    BlockStm::BlockStm(StatementList* stml)
        : Statement(StatementType::blockStm),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }
    BlockStm::BlockStm()
        : Statement(StatementType::blockStm),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = nullptr;
    }
    BlockStm::~BlockStm() {}
    const StatementList* BlockStm::getStatementList()const {
        return pImpl->m_StatementList;
    }

    //--------------------------------------------------------------------------------------
    ///  文リストクラス
    //--------------------------------------------------------------------------------------
    struct StatementList::Impl {
        const Statement* m_Statement;
        StatementList* m_Next;
    };

    StatementList::StatementList(const Statement* stm):
        ObjeBase(ObjType::StmListType),
        pImpl(new Impl)
    {
        pImpl->m_Statement = stm;
        pImpl->m_Next = nullptr;
    }
    StatementList::~StatementList() {
        delete pImpl;
    }

    const Statement* StatementList::getStm() const {
        return pImpl->m_Statement;
    }


    StatementList* StatementList::getNext()const {
        return pImpl->m_Next;
    }
    void StatementList::setNext(StatementList* next) {
        pImpl->m_Next = next;
    }

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    struct Root::Impl {
        const StatementList* m_StatementList;
    };

    Root::Root(const StatementList* stml):
        ObjeBase(ObjType::RootType),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }
    Root::~Root() {
        delete pImpl;
    }

    void Root::Excute()const {
        if (pImpl->m_StatementList) {
            auto pos = pImpl->m_StatementList;
            do {
                pos->getStm()->Excute();
                pos = pos->getNext();
            } while(pos);
        }
    }

}
//end namespace ore
</pre>
</div>
<h4>Interpreter.cppの記述</h4>
　続いて先ほど作成した<b>Interpreter.cpp</b>です。
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include "proc.h"
using namespace std;

namespace ore {

#define ORE_MAX_TOKEN_LEN 255

    ///stringを255文字に切り詰める
    string clampToken(const char* ext) {
        string str(ext);
        if (str.size() > ORE_MAX_TOKEN_LEN) {
            str.erase(ORE_MAX_TOKEN_LEN);
        }
        return str;
    }

    //--------------------------------------------------------------------------------------
    ///  インタープリタクラス
    //--------------------------------------------------------------------------------------
    Interpreter* Interpreter::getInp() {
        static Interpreter* instance = nullptr;
        if (!instance) {
            instance = new Interpreter;
        }
        return instance;
    }

    struct Interpreter::Impl {
        set&lt;string> m_FixedStringPool;
        vector&lt;ObjeBase*> m_ObjectPool;
        Root* m_Root;
    };

    Interpreter::Interpreter() :
        pImpl(new Impl)
    {
        pImpl->m_Root = nullptr;
    }
    Interpreter::~Interpreter() {
        delete pImpl;
    }

    int Interpreter::Compile(FILE *fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;
    }
    void Interpreter::Exec() {
        if (pImpl->m_Root) {
            pImpl->m_Root->Excute();
        }
    }
    void Interpreter::Delete() {
        for (auto v : pImpl->m_ObjectPool) {
            delete v;
        }
    }

    const char* Interpreter::createFixedString(const char* ext) {
        //255文字に切り詰める。
        auto str = clampToken(ext);
        auto it = pImpl->m_FixedStringPool.insert(str);
        return it.first->c_str();
    }


    Expression* Interpreter::createIdentifierExp(const char* ext) {
        auto ptr = new IdentifierExp(ext);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createDoubleValueExp(const char* ext) {
        auto ptr = new DoubleValueExp();
        ptr->setDoubleValue(std::atof(ext));
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }


    Statement* Interpreter::createExpressionStm(const Expression *exp) {
        auto ptr = new ExpressionStm(exp);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Statement* Interpreter::createPrintStm(const Expression* exp, bool nflg) {
        auto ptr = new PrintStm(exp, nflg);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    StatementList* Interpreter::createStatementList(const Statement* stm) {
        auto ptr = new StatementList(stm);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    StatementList* Interpreter::createStatementList(StatementList* stml, const Statement* stm) {
        StatementList *pos;
        if (stml == nullptr)
            return createStatementList(stm);
        for (pos = stml; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createStatementList(stm));
        return stml;
    }

    Statement* Interpreter::createBlockStm() {
        auto ptr = new BlockStm;
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Statement* Interpreter::createBlockStm(StatementList* stml) {
        auto ptr = new BlockStm(stml);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Root*  Interpreter::createRoot(const StatementList* stml) {
        auto ptr = new Root(stml);
        pImpl->m_ObjectPool.push_back(ptr);
        //インタプリタのrootにセット
        pImpl->m_Root = ptr;
        return ptr;
    }


}
//end namespace ore
</pre>
</div>
<h4>main.cppの書き換え</h4>
　続いて<b>main.cpp</b>です。以下のようにします。
<div class="box1">
<pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;iostream>
#include &lt;fstream>
#include &lt;vector>
#include &lt;string>
#include "proc.h"
using namespace std;


class InputParser {
    vector &lt;string> tokens;
public:
    InputParser(int &argc, char **argv) {
        for (int i = 1; i &lt; argc; ++i) {
            tokens.push_back(string(argv[i]));
        }
    }
    const string& getCmdOption(const string &option) const {
        vector&lt;string>::const_iterator itr;
        itr = find(tokens.begin(), tokens.end(), option);
        if (itr != tokens.end() && ++itr != tokens.end()) {
            return *itr;
        }
        static const string empty_string("");
        return empty_string;
    }
    bool cmdOptionExists(const string &option) const {
        return find(tokens.begin(), tokens.end(), option)
            != tokens.end();
    }
};


int main(int argc, char **argv) {
    InputParser input(argc, argv);
    const string &filename = input.getCmdOption("-f");
    if (filename.empty()) {
        cerr &lt;&lt; "ファイルを指定してください" &lt;&lt; endl;
        return 1;
    }
    errno_t err;
    FILE* fp;
    if((err = fopen_s(&fp, filename.c_str(), "r")) != 0) {
        cerr &lt;&lt; "ファイル読み込みに失敗しました" &lt;&lt; std::endl;
        return 1;
    }
    auto tntp = ore::Interpreter::getInp();
    if(tntp->Compile(fp)) {
        cerr &lt;&lt; "エラー終了" &lt;&lt; endl;
        return 1;
    }
    tntp->Exec();
    tntp->Delete();
    return 0;
}
</pre>
</div>
<h4>oreProject.lの書き換え</h4>
　続いて<b>Flex</b>ファイルです。<b>FlexBisonプロジェクト</b>の<b>oreProject.l</b>を以下のようにします。
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include "oreProject.tab.h"
#include "../oreProject/proc.h"
#define YY_SKIP_YYWRAP 1
int gLine = 1;
int yywrap(void){ return 1; }

%}
%s COMMENT
%s LINE_COMMENT
%%
&lt;INITIAL>{
    "{"    return LC;
    "}"    return RC;
    ";"     return SEMICOLON;
    "*="    return MULASS;
    "/="    return DIVASS;
    "+="    return ADDASS;
    "-="    return SUBASS;
    "+"     return ADD;
    "-"     return SUB;
    "*"     return MUL;
    "/"     return DIV;
    "="     return ASS;
    "pn"    return PRINTN;
    "p"     return PRINT;
    "/*"    { BEGIN(COMMENT);}
    [/][/]+ { BEGIN(LINE_COMMENT);}
    [1-9][0-9]* {
        yylval.expression = ore::Interpreter::getInp()->createDoubleValueExp(yytext);
        return DOUBLE_LITERAL;
    }
    [0-9]*\.[0-9]* {
        yylval.expression = ore::Interpreter::getInp()->createDoubleValueExp(yytext);
        return DOUBLE_LITERAL;
    }
    [A-Za-z_][A-Za-z_0-9]* {
        yylval.fixedString = ore::Interpreter::getInp()->createFixedString(yytext);
        return IDENTIFIER;
    }
    "\n"    {gLine++;}
    [ \t]   ;
    .   { return 0;}
}
&lt;COMMENT>{
    "\n"    {gLine++;}
    "*/" {BEGIN(INITIAL);}
    .   ;
}
&lt;LINE_COMMENT>{
    "\n" { gLine++; BEGIN(INITIAL);}
    .   ;
}
%%
</pre>
</div>
<h4>oreProject.yの書き換え</h4>
　続いて<b>Bison</b>の<b>oreProject.y</b>です。
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include "../oreProject/proc.h"
#define YYDEBUG 1
extern int yylex(void);
int yyerror(char const *str){
    extern char *yytext;
    extern int gLine;
    fprintf(stderr,"%s, line: %d, near %s\n",str, gLine, yytext);
    return 0;
}
%}

%code requires {
#include "../oreProject/proc.h"
}

%union {
    const char* fixedString;
    ore::Expression* expression;
    ore::Statement *statement;
    ore::StatementList* statement_list;
    ore::Root* root;
}
%token &lt;fixedString> IDENTIFIER
%token &lt;expression>  DOUBLE_LITERAL
%token  LC RC SEMICOLON ADD SUB MUL DIV CR MULASS DIVASS  ADDASS SUBASS ASS PRINTN PRINT
%type &lt;expression> expression primary_expression
%type &lt;statement> statement
%type &lt;statement_list> statement_list
%type &lt;root> root
%%
root
    :statement_list
    {
        $$ = ore::Interpreter::getInp()->createRoot($1);
    }
    ;
statement_list
    : statement
    {
        $$ = ore::Interpreter::getInp()->createStatementList($1);
    }
    | statement_list statement
    {
        $$ = ore::Interpreter::getInp()->createStatementList($1,$2);
    }
    ;
statement
    : SEMICOLON
    | expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createExpressionStm($1);
    }
    | LC statement_list RC
    {
        $$ = ore::Interpreter::getInp()->createBlockStm($2);
    }
    | LC RC
    {
        $$ = ore::Interpreter::getInp()->createBlockStm();
    }
    | PRINT expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createPrintStm($2,false);
    }
    | PRINTN expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createPrintStm($2,true);
    }
    ;
expression
    : add_expression
    | IDENTIFIER MULASS expression
    {
    }
    | IDENTIFIER DIVASS expression
    {
    }
    | IDENTIFIER ADDASS expression
    {
    }
    | IDENTIFIER SUBASS expression
    {
    }
    | IDENTIFIER ASS expression
    {
    }
    ;
add_expression
    : mul_expression
    | add_expression ADD mul_expression
    {
    }
    | add_expression SUB mul_expression
    {
    }
    ;
mul_expression
    : primary_expression
    | mul_expression MUL primary_expression
    {
    }
    | mul_expression DIV primary_expression
    {
    }
    ;
primary_expression
    : DOUBLE_LITERAL
    {
        $$ = $1;
    }
    | IDENTIFIER
    {
        $$ = ore::Interpreter::getInp()->createIdentifierExp($1);
    }
    ;
%%
</pre>
</div>
<h4>index.oreの書き換え</h4>
　最後に<b>index.ore</b>です。以下の記述をします。
<div class="box1">
<pre>
var;
</pre>
</div>
　１行だけですね。テストにはこれで充分です。<br />
<h4>ビルドと実行</h4>
　それでは<b>リビルド</b>して<b>デバッグなしで実行</b>してみましょう。
<div class="box1">
<pre>

...\oreProject\Debug\oreProject.exe (プロセス 8660) は、コード 0 を伴って終了しました。
このウィンドウを閉じるには、任意のキーを押してください . . .
</pre>
</div>
　と出れば成功です。<br />
　<b>何も表示されないじゃないか？</b>って？<br />
　<b>コード0</b>つまりエラーもなく終了したので、これで良いのです。<br />
　では次項で解説します。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="04_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
