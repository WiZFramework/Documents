<!doctype html>
<html lang="ja">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<link href="css/bootStyle.css" rel="stylesheet">

<title>言語を作ろうプロジェクト（2022年）</title>
</head>
<body>
<header class="sticky-top">
  <div>
<h3>２３．構造を考える</h3>
  </div>
</header>
<!--container-->
<div class="container">
  <main>
    <!--row-->
    <div class="row">
      <!--col-->
      <div class="col">
<h4>２３－０２．識別子</h4>
<h5>driverクラスの修正</h5>
　この項では「変数」を実装してみます。ここで「変数」とは、任意の名前を持ち、double型の値をセットできるオブジェクトとします。<br>
　まず、「driver.h」を書き換えます。
<pre>
#ifndef DRIVER_H
#define DRIVER_H
#include &lt;iostream>
#include &lt;fstream>
#include &lt;string>
#include &lt;map>

using namespace std;

enum class valType{
  intType,
  doubleType,
  stringType,
  boolType,
  endType
};

class exp{
  valType m_valueType;
  int m_intVal;
  double m_doubleVal;
  bool m_boolVal;
  string m_strVal;
public:
  exp():
    m_valueType(valType::endType),
    m_intVal(0),
    m_doubleVal(0.0),
    m_boolVal(false),
    m_strVal()
  {}
  exp(const exp& other):
    m_valueType(other.m_valueType),
    m_intVal(other.m_intVal),
    m_doubleVal(other.m_doubleVal),
    m_boolVal(other.m_boolVal),
    m_strVal(other.m_strVal)
  {}
  exp& operator =(const exp& other){
    m_valueType = other.m_valueType;
    m_intVal = other.m_intVal;
    m_doubleVal = other.m_doubleVal;
    m_boolVal = other.m_boolVal;
    m_strVal = other.m_strVal;
    return *this;
  
  }
#define STR_BUFFSIZE 100  
  exp& operator +=(const exp& other){
  char buff[STR_BUFFSIZE];
  switch(m_valueType){
    case valType::intType:
      switch(other.m_valueType){
        case valType::intType:
          m_intVal += other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_intVal += (int)other.m_doubleVal;
          return *this;
        break;
        case valType::stringType:
          m_intVal += atoi(other.m_strVal.c_str());
          return *this;
        break;
        default:
        break;
      }
    break;
    case valType::doubleType:
      switch(other.m_valueType){
        case valType::intType:
          m_doubleVal += (double)other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_doubleVal += other.m_doubleVal;
          return *this;
        break;
        case valType::stringType:
          m_doubleVal += atof(other.m_strVal.c_str());
          return *this;
        break;
        default:
        break;
      }
    break;
    case valType::stringType:
      switch(other.m_valueType){
        case valType::intType:
          snprintf(buff,STR_BUFFSIZE, "%d",other.m_intVal);
          m_strVal += buff;
          return *this;
        break;
        case valType::doubleType:
          snprintf(buff,STR_BUFFSIZE, "%f",other.m_doubleVal);
          m_strVal += buff;
          return *this;
        break;
        case valType::stringType:
          m_strVal += other.m_strVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    default:
    break;
  }
    return *this;
  }
  
  exp operator +(const exp& other){
  exp temp = *this;
  temp += other;
  return temp;
  }
  
  
  exp& operator -=(const exp& other){
  char buff[STR_BUFFSIZE];
  switch(m_valueType){
    case valType::intType:
      switch(other.m_valueType){
        case valType::intType:
          m_intVal -= other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_intVal -= (int)other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    case valType::doubleType:
      switch(other.m_valueType){
        case valType::intType:
          m_doubleVal -= (double)other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_doubleVal -= other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    default:
    break;
  }
    return *this;
  }
  
  exp operator -(const exp& other){
  exp temp = *this;
  temp -= other;
  return temp;
  }
  
  
  exp& operator /=(const exp& other){
  char buff[STR_BUFFSIZE];
  switch(m_valueType){
    case valType::intType:
      switch(other.m_valueType){
        case valType::intType:
          if(other.m_intVal == 0){
            break;
          }
          m_intVal /= other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          if(other.m_doubleVal == 0.0){
            break;
          }
          m_intVal /= (int)other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    case valType::doubleType:
      switch(other.m_valueType){
        case valType::intType:
          if(other.m_intVal == 0){
            break;
          }
          m_doubleVal /= (double)other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          if(other.m_doubleVal == 0.0){
            break;
          }
          m_doubleVal /= other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    default:
    break;
  }
    return *this;
  }
  
  exp operator /(const exp& other){
  exp temp = *this;
  temp /= other;
  return temp;
  }
  
  exp& operator *=(const exp& other){
  char buff[STR_BUFFSIZE];
  switch(m_valueType){
    case valType::intType:
      switch(other.m_valueType){
        case valType::intType:
          m_intVal *= other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_intVal *= (int)other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    case valType::doubleType:
      switch(other.m_valueType){
        case valType::intType:
          m_doubleVal *= (double)other.m_intVal;
          return *this;
        break;
        case valType::doubleType:
          m_doubleVal *= other.m_doubleVal;
          return *this;
        break;
        default:
        break;
      }
    break;
    default:
    break;
  }
    return *this;
  }
  
  exp operator *(const exp& other){
  exp temp = *this;
  temp *= other;
  return temp;
  }
  
  
  valType getValueType() const{
    return m_valueType;
  }
  void setValueType(valType type){
    m_valueType = type;
  }
  
  int getIntVal() const{
    return m_intVal;
  }
  void setIntVal(int val){
    m_intVal = val;
  }
  double getDoubleVal() const{
    return m_doubleVal;
  }
  void setDoubleVal(double val) {
    m_doubleVal = val;
  }
  string& getStrVal(){
    return m_strVal;
  }
  void setStrVal(const string& str){
    m_strVal = str;
  }
  bool getBoolVal()const{
    return m_boolVal;
  }
  void setBoolVal(bool b){
    m_boolVal = b;
  }
};

class driver
{
    driver ();
  map&lt;std::string,double> m_variables;
public:
    void output(double a);
    double createNUM(const string& a);
    double createIDENTIFIER(const string& idnt);

    int parse (const string& f);
    string m_file;
    static driver* get();

};

#endif // ! DRIVER_H
</pre>
　続いて、「driver.cpp」を書き換えます。
<pre>
#include "driver.h"

driver::driver ()
{
}

void driver::output(double a){
    cout &lt;&lt; ">>" &lt;&lt; a &lt;&lt; std::endl;
}

double driver::createNUM(const string& a){
    double d = (double)strtof(a.c_str(),nullptr);
    return d;
}

double driver::createIDENTIFIER(const string& idnt){
    return m_variables[idnt];
}


driver* driver::get(){
    static driver* instance = nullptr;
    if(!instance){
      instance = new driver();
    }
    return instance;
}

int
driver::parse (const string &f)
{
    extern int yyparse(void);
    extern FILE* yyin;
    m_file = f;

    if ((yyin = fopen(m_file.c_str(), "r")) == NULL) {
        cerr &lt;&lt; "ファイル読み込みに失敗しました" &lt;&lt; endl;
        return 1;
    }
    if (yyparse()) {
        cout &lt;&lt; "プログラム終了" &lt;&lt; endl;
        return 1;
    }
    return 0;
}
</pre>
　続いて「parser.y」です。
<pre>
%{
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;iostream>
#include "driver.h"

#define YYDEBUG 1

extern int yylex(void);

int
yyerror(char const *str)
{
    extern char *yytext;
    fprintf(stderr, "parser error near %s\n", yytext);
    return 0;
}

%}
%union {
    double  double_value;
    char* literal_value;
}
%token &lt;double_value>    DOUBLE_VALUE
%token &lt;literal_value>   DOUBLE_LITERAL_PTR IDENTIFIER_PTR
%token
  ADD "+"
  SUB "-"
  MUL "*"
  DIV "/"
  CR
;
%type &lt;double_value> expression term primary_expression
%%
line_list
    : line
    | line_list line
    ;
line
    : expression CR
    {
        driver::get()->output($1);
    }
expression
    : term
  | IDENTIFIER_PTR 
  {
        $$ = driver::get()->createIDENTIFIER($1);
  }
    | expression "+" term
    {
        $$ = $1 + $3;
    }
    | expression "-" term
    {
        $$ = $1 - $3;
    }
    ;
term
    : primary_expression
    | term "*" primary_expression 
    {
        $$ = $1 * $3;
    }
    | term "/" primary_expression
    {
        $$ = $1 / $3;
    }
    ;
primary_expression
    : DOUBLE_LITERAL_PTR
    {
        $$ = driver::get()->createNUM($1);
    }
    ;
%%
</pre>
　続いて「scanner.l」です。
<pre>
%{
#include &lt;stdio.h>
#include "parser.hpp"
#include "driver.h"

#define YY_SKIP_YYWRAP 1

int
yywrap()
{
    return 1;
}
%}

id    [a-zA-Z][a-zA-Z_0-9]*
blank [ \t]
int   [1-9][0-9]*
double [0-9]*\.[0-9]*


%%
{blank}+ ;
"+"     return ADD;
"-"     return SUB;
"*"     return MUL;
"/"     return DIV;
"\n"    return CR;
{int} {
    yylval.literal_value = yytext;
    return DOUBLE_LITERAL_PTR;
}
{double} {
    yylval.literal_value = yytext;
    return DOUBLE_LITERAL_PTR;
}
{id} {
    yylval.literal_value = yytext;
    return IDENTIFIER_PTR;
}
%%
</pre>
　以下、変更はありませんが「main.cpp」です。<br>
<pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;iostream>
#include &lt;fstream>
#include &lt;vector>
#include &lt;string>
#include "driver.h"

using namespace std;

int
main (int argc, char *argv[])
{
    driver* drv = driver::get();
    for (int i = 1; i &lt; argc; ++i){
        return drv->parse(argv[i]);
    }
    return 0;
}
</pre>
　変更がありませんが「Makefile」です。
<pre>
calcCpp : scanner.cpp parser.hpp parser.cpp main.cpp driver.cpp driver.h
&#009;g++ -o calcCpp scanner.cpp parser.cpp driver.cpp main.cpp

scanner.cpp : scanner.l
&#009;flex -o scanner.cpp scanner.l

parser.hpp parser.cpp : parser.y
&#009;bison -d -o parser.cpp parser.y
</pre>
　以下、スクリプトファイルです「test.txt」です。
<pre>
10 + 3
10 * 3
</pre>

      </div>
      <!--/col-->
    </div>
    <!--/row-->
  </main>
  <!--/main-->
  <footer id="footer" class="fixed-bottom text-center">
    <ul>
      <li class="list-inline-item"><a href="23_01.html">前ページ</a></li>
      <li class="list-inline-item"><a href="index.html">目次</a></li>
      <li class="list-inline-item"><a href="23_03.html">次ページ</a></li>
    </ul>
  </footer>
</div>
<!--/container-->
<!-- Optional JavaScript; choose one of the two! -->
<!-- Option 1: Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- Option 2: Separate Popper and Bootstrap JS -->
<!--
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
-->
</body>
</html>
