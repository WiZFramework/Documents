<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０３．トレース言語とインタプリタ</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０３－１３．Interpreterクラスの修正とランタイム</h3>
<h4>Interpreterクラスの修正</h4>
　この項では<b>０３－０８．インタプリタへの修正</b>で作成した<b>Interpreterクラス</b>を修正して、<b>値、式、文クラス</b>の構造に合わせてカスタマイズ（つまり、式や文の追加）が容易になるように変更します。<br />
　まず、<b>interpreter.h</b>ですが、以下のように書き換えます。
<div class="box1">
<pre>
#pragma once

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    class Root : public StmExBase {
    public:
        Root(const StatementList* stml);
        virtual ~Root();
        virtual SmtRes Excute() const  override;
        const StatementList* getStmeList()const;
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

    //--------------------------------------------------------------------------------------
    ///  インタープリタクラス
    //--------------------------------------------------------------------------------------
    class Interpreter : public ObjBase {
        Interpreter();
    public:
        virtual ~Interpreter();
        int Compile(FILE *fp);
        void Exec() const;
        void Delete();
        ///Util
        void setConfig(const char* key, const Value val);
        Value getConfig(const char* key);
        void pushBackObject(ObjBase* pobj);
        const char* createFixedString(const char* ext);
        ///Expression
        Expression* createVariableExp(const char* ident);
        Expression* createDoubleLiteralExp(const char* ext);
        Expression* createBinaryExp(const Expression* left, const Expression* right, ExpressionType t);
        Expression* createAssExp(const Expression* ident, const Expression* right);
        Expression* createToAssExp(const Expression* ident, const Expression* right, ExpressionType t);
        ///Statement
        //Util template
        template&lt;typename T, typename... Ts>
        Statement* createStatement(Ts&&... params) {
            auto ptr = new T(params...);
            pushBackObject(ptr);
            return ptr;
        }
        ///StatementList
        StatementList* createStatementList(const Statement* stm);
        StatementList* createStatementList(StatementList* stml, const Statement* stm);
        //Root
        Root*  createRoot(const StatementList* stml);
        //インスタンス参照
        static Interpreter* getInp();
        ///Exec関連
        ///変数の値の参照を取得
        Value& getGlobalValiableValue(const char* key);
        ///シンタックスエラー予約語関連
        void syntaxKeepExit(int mess_id, const char* detail);
        ///シンタックスエラー(行番号、位置情報付き)
        void syntaxExit(int mess_id, int linnum, const char* detail, bool bison = true);
        ///ランタイム中の行番号
        void setRuntimeLineNumber(int num);
        int getRuntimeLineNumber() const;
        ///ランタイムエラー(行番号付き)
        void runtimeExit(int mess_id, const char* target = nullptr);
        ///ランタイムワーニング
        void runtimeWorning(int mess_id);
        ///警告を出すかどうか
        bool isWorningOut() const;
        void setWorningOut(bool b);
    private:
        // pImplイディオム
        struct Impl;
        Impl* pImpl;
    };

}
//end namespace ore
</pre>
</div>
　続いて<b>interpreter.cpp</b>を以下のように書き換えます。
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include "util.h"
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    struct Root::Impl {
        const StatementList* m_StatementList;
    };

    Root::Root(const StatementList* stml) :
        StmExBase(ObjType::RootType),
        pImpl(new Impl)
    {
        pImpl->m_StatementList = stml;
    }

    Root::~Root() {
        delete pImpl;
    }

    const StatementList* Root::getStmeList()const {
        return pImpl->m_StatementList;
    }

    SmtRes Root::Excute()const {
        setRuntimeLineNumber();
        if (pImpl->m_StatementList) {
            auto pos = pImpl->m_StatementList;
            do {
                auto stm = pos->getStm();
                stm->Excute();
                pos = pos->getNext();
            } while (pos);
        }
        else {
            Interpreter::getInp()->runtimeExit(2001);
        }
        return SmtRes();
    }

    //--------------------------------------------------------------------------------------
    ///  ランタイムオブジェクト
    //--------------------------------------------------------------------------------------
    struct RuntimeObject : public std::enable_shared_from_this&lt;RuntimeObject> {
        bool m_IsFunc;
        //変数のmap
        map&lt;string, Value> m_VariableMap;
        //ツリー構造
        weak_ptr&lt;RuntimeObject> m_Parent;
        shared_ptr&lt;RuntimeObject> m_Child;
        RuntimeObject(shared_ptr&lt;RuntimeObject> parent, bool IsFunc = false) :
            m_Parent(parent), m_Child(nullptr), m_IsFunc(IsFunc)
        {}
        ~RuntimeObject() {}
    };

    //--------------------------------------------------------------------------------------
    ///  インタープリタクラス
    //--------------------------------------------------------------------------------------
    Interpreter* Interpreter::getInp() {
        static Interpreter* instance = nullptr;
        if (!instance) {
            instance = new Interpreter;
        }
        return instance;
    }

    struct Interpreter::Impl {
        set&lt;string> m_FixedStringPool;
        vector&lt;ObjBase*> m_ObjectPool;
        map&lt;string, string> m_ConfigMap;
        //ランタイムエラー用テンポラリ
        Value m_TempVal;
        Root* m_Root;
        shared_ptr&lt;RuntimeObject> m_RootRuntime;
        //エラーのマップ
        map&lt;int, string> m_ErrMap;
        //警告を表示するかどうか
        bool m_IsWorningOut;
        //ランタイム中の行番号
        int m_RuntimeLineNumber;
    };

    Interpreter::Interpreter() :
        ObjBase(ObjType::InterpreterType),
        pImpl(new Impl)
    {
        pImpl->m_Root = nullptr;
        pImpl->m_ErrMap =
        {
            { 0001, "をみでくんつえ。" },
            { 0002, "その手前がもしんねぞい。" },
            { 1001, "ファイルのなめえ（名前）が指定されてないぞい。" },
            { 1002, "ファイルを読むのに失敗したぞい。" },
            { 1003, "書ぎがだがまじがってんぞい。" },
            { 1004, "関数名はすでにつかわれでっつおい。"},
            { 1005, "関数が見づがんねぞい。ない関数を呼んだってだめだべ。よぶどごより上で作ってくんつえ。"},
            { 2001, "実行文がねがら動がせねぞい。" },
            { 2002, "なんだがわがんねエラーだぞい" },
            { 2003, "0では割れねぞい。んなごど、とっぐにわがってっぺ。" },
            { 2004, "演算でぎねぞい"},
            { 2005, "右辺が負の数だと文字列の掛け算はでぎねぞい。正の数字ならでぎっつおい。" },
            { 2006, "左辺が文字列だと引き算でぎねぞい。足し算か掛け算ならでぎっつおい。" },
            { 2007, "左辺が文字列だと割り算でぎねぞい。足し算か掛け算ならでぎっつおい。" },
            { 2008, "bool型はほかの型とは比較でぎねぞい。bool同士ならでぎっつおい。" },
            { 2009, "文字列は比較でぎねぞい" },
            { 2010, "比較演算がでぎねぞい"},
            { 2011, "ローカル変数は関数のながでしがつぐれねぞい。"},
            { 2012, "定義関数で、キーが空白でねえがい？"},
            { 2013, "関数呼び出しで、パラメータ数より実引数が多いぞい。関数定義をよぐみでくんつえ。"},
            { 2014, "関数のながに関数をづぐろうどしてんべ。すまねが、それはでぎんよ。"},
            { 2015, "なんだがわがんねげど、ループがスイッチが開いてねえが閉じてねえどごがあんぞい。"},
            { 2016, "ブレーク文はループの中がスイッチのながしかかげねぞい。"},
            { 2017, "リターン文は関数内でしかかげねぞい。"},
            { 2018, "コンティニュー文はループの中しかかげねぞい。"},
            { 2019, "配列の添え字は正の整数か文字列だぞい"},
            { 2020, "親配列がないぞい"},
            { 2021, "配列はほがの型に変換でぎねぞい。"},
            { 2022, "その配列の添え字はめっかんねぞい。"},
        };

        //初期状態はワーニングを出す
        pImpl->m_IsWorningOut = true;
        pImpl->m_RuntimeLineNumber = 1;
        pImpl->m_TempVal = Value();
        pImpl->m_ConfigMap["calc_epsilon"] = "0.000001";
    }
    Interpreter::~Interpreter() {
        delete pImpl;
    }

    int Interpreter::Compile(FILE *fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;
    }

    void Interpreter::Exec()const {
        if (pImpl->m_Root) {
            pImpl->m_RootRuntime = make_shared&lt;RuntimeObject>(nullptr);
            pImpl->m_Root->Excute();
        }
        else {
            Interpreter::getInp()->runtimeExit(2001);
        }
    }

    void Interpreter::Delete() {
        for (auto v : pImpl->m_ObjectPool) {
            delete v;
        }
        pImpl->m_ObjectPool.clear();
        pImpl->m_FixedStringPool.clear();
    }

    void Interpreter::setConfig(const char* key, const Value val) {
        //congigファイルは文字列
        string keystr = key;
        string valstr = val.getString();
        if (keystr == "") {
            runtimeExit(2012);
        }
        pImpl->m_ConfigMap[keystr] = valstr;
    }

    Value Interpreter::getConfig(const char* key) {
        //congigファイルは文字列
        string keystr = key;
        if (keystr == "") {
            runtimeExit(2012);
        }
        return Value(pImpl->m_ConfigMap[keystr].c_str());
    }

    void Interpreter::pushBackObject(ObjBase* pobj) {
        pImpl->m_ObjectPool.push_back(pobj);
    }

    const char* Interpreter::createFixedString(const char* ext) {
        //255文字に切り詰める。
        auto str = clampToken(ext);
        auto it = pImpl->m_FixedStringPool.insert(str);
        return it.first->c_str();
    }

    Expression* Interpreter::createVariableExp(const char* ident) {
        string str = clampToken(ident);
        auto ptr = new VariableExp(str.c_str());
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createDoubleLiteralExp(const char* ext) {
        string str = clampToken(ext);
        auto ptr = new DoubleLiteralExp(std::stod(str));
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createBinaryExp(const Expression* left, const Expression* right, ExpressionType t) {
        auto ptr = new BinaryExp(t, left, right);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createAssExp(const Expression* ident, const Expression* right) {
        auto ptr = new AssignExp(ident, right);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    Expression* Interpreter::createToAssExp(const Expression* ident, const Expression* right, ExpressionType t) {
        auto ptr = new ToAssExp(ident, right, t);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    StatementList* Interpreter::createStatementList(const Statement* stm) {
        auto ptr = new StatementList(stm);
        pImpl->m_ObjectPool.push_back(ptr);
        return ptr;
    }

    StatementList* Interpreter::createStatementList(StatementList* stml, const Statement* stm) {
        StatementList *pos;
        if (stml == nullptr)
            return createStatementList(stm);
        for (pos = stml; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createStatementList(stm));
        return stml;
    }

    Root*  Interpreter::createRoot(const StatementList* stml) {
        auto ptr = new Root(stml);
        pImpl->m_ObjectPool.push_back(ptr);
        //インタプリタのrootにセット
        pImpl->m_Root = ptr;
        return ptr;
    }

    ///変数の値を取得
    Value& Interpreter::getGlobalValiableValue(const char* key) {
        //ルートの変数（グローバル変数）を得る
        auto it = pImpl->m_RootRuntime->m_VariableMap.find(key);
        if (it != pImpl->m_RootRuntime->m_VariableMap.end()) {
            //見つかった
            return it->second;
        }
        else {
            //無かったので作成
            //stringで作成
            pImpl->m_RootRuntime->m_VariableMap[key] = Value("");
            return pImpl->m_RootRuntime->m_VariableMap[key];
        }
    }

    void Interpreter::setRuntimeLineNumber(int num) {
        pImpl->m_RuntimeLineNumber = num;

    }
    int Interpreter::getRuntimeLineNumber() const {
        return pImpl->m_RuntimeLineNumber;
    }

    void Interpreter::syntaxKeepExit(int mess_id, const char* detail) {
        cerr &lt;&lt; "\n"
            &lt;&lt; pImpl->m_ErrMap[1003]
            &lt;&lt; detail
            &lt;&lt; ": "
            &lt;&lt; pImpl->m_ErrMap[mess_id]
            &lt;&lt; endl;
        exit(1);
    }


    void Interpreter::syntaxExit(int mess_id, int linnum, const char* detail, bool bison) {
        string detailstr = detail;
        if (bison) {
            if (detailstr != "") {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目: "
                    &lt;&lt; detailstr
                    &lt;&lt; " あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; pImpl->m_ErrMap[0002]
                    &lt;&lt; endl;
            }
            else {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; endl;

            }
        }
        else {
            if (detailstr != "") {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目: "
                    &lt;&lt; detailstr
                    &lt;&lt; " あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; pImpl->m_ErrMap[0002]
                    &lt;&lt; endl;
            }
            else {
                cerr &lt;&lt; "\n"
                    &lt;&lt; pImpl->m_ErrMap[mess_id]
                    &lt;&lt; linnum
                    &lt;&lt; " 行目あだり"
                    &lt;&lt; pImpl->m_ErrMap[0001]
                    &lt;&lt; endl;
            }
        }
        exit(1);
    }

    void Interpreter::runtimeExit(int mess_id, const char* target) {
        if (target) {
            cerr &lt;&lt; "\n動がしてるどきのまじがいだぞい。 "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; target
                &lt;&lt; " "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;

        }
        else {
            cerr &lt;&lt; "\n動がしてるどきのまじがいだぞい。 "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;

        }
        exit(1);
    }

    void Interpreter::runtimeWorning(int mess_id) {
        if (isWorningOut()) {
            cerr &lt;&lt; "\n動がしてるどきだげんんちょ、いじおう言っておぐ, "
                &lt;&lt; getRuntimeLineNumber()
                &lt;&lt; " 行目: "
                &lt;&lt; pImpl->m_ErrMap[mess_id]
                &lt;&lt; endl;
        }
    }

    bool Interpreter::isWorningOut() const {
        return pImpl->m_IsWorningOut;

    }
    void Interpreter::setWorningOut(bool b) {
        pImpl->m_IsWorningOut = b;
    }

}
//end namespace ore
</pre>
</div>
<h4>main()関数の修正</h4>
　最後に<b>main()関数</b>を修正します。<b>main.cpp</b>にあります。
<div class="box1">
<pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;iostream>
#include &lt;fstream>
#include &lt;vector>
#include &lt;string>
#include "proc.h"
using namespace std;

class InputParser {
    vector &lt;string> tokens;
public:
    InputParser(int &argc, char **argv) {
        for (int i = 1; i &lt; argc; ++i) {
            tokens.push_back(string(argv[i]));
        }
    }
    const string& getCmdOption(const string &option) const {
        vector&lt;string>::const_iterator itr;
        itr = find(tokens.begin(), tokens.end(), option);
        if (itr != tokens.end() && ++itr != tokens.end()) {
            return *itr;
        }
        static const string empty_string("");
        return empty_string;
    }
    bool cmdOptionExists(const string &option) const {
        return find(tokens.begin(), tokens.end(), option)
            != tokens.end();
    }
};

int main(int argc, char **argv) {
    InputParser input(argc, argv);
    const string &filename = input.getCmdOption("-f");
    if (filename.empty()) {
        ore::Interpreter::getInp()->syntaxExit(1001, 0, "");
        return 1;
    }
    errno_t err;
    FILE* fp;
    if ((err = fopen_s(&fp, filename.c_str(), "r")) != 0) {
        ore::Interpreter::getInp()->syntaxExit(1002, 0, "");
        return 1;
    }
    <span class="red">auto itp = ore::Interpreter::getInp();
    if (itp->Compile(fp)) {
        return 1;
    }
    itp->Exec();
    itp->Delete();</span>
    return 0;
}
</pre>
</div>
　ここでは登録されたエラーメッセージが、出力するように修正しています。
<h4>解説</h4>
　ここで紹介するいくつかのクラスは、<b>マネージャ</b>的な動きをするクラス群です。<br />
　<b>oreProject</b>は
<div class="box1">
<pre>
１、コンパイル
２、実行
３、破棄
</pre>
</div>
　の3つの動作をして1連の実行を終了します。<br />
　そしてそのための<b>部品</b>となるのが
<div class="box1">
<pre>
１、値（Valueクラス）
２、式（Expressionクラスとその関連）
３、文（Statementクラスとその関連）
</pre>
</div>
　です。<br />
　そしてその部品たちを制御するのが、この項で紹介する<b>Interpreterクラスとその関連</b>となります。<br />
　<b>C/C++</b>は、先ほど修正した<b>main()関数</b>から始まり<b>main()関数</b>で終わります。<br />
　まず、その<b>main()関数</b>を見てみましょう。
<div class="box1">
<pre>
int main(int argc, char **argv) {
    InputParser input(argc, argv);
    const string &filename = input.getCmdOption("-f");
    if (filename.empty()) {
        ore::Interpreter::getInp()->syntaxExit(1001, 0, "");
        return 1;
    }
    errno_t err;
    FILE* fp;
    if ((err = fopen_s(&fp, filename.c_str(), "r")) != 0) {
        ore::Interpreter::getInp()->syntaxExit(1002, 0, "");
        return 1;
    }
    <span class="red">auto itp = ore::Interpreter::getInp();
    if (itp->Compile(fp)) {
        return 1;
    }
    itp->Exec();
    itp->Delete();</span>
    return 0;
}
</pre>
</div>
　赤くなっているところが<b>Interpreterクラス</b>にかかわるところです。
<div class="box1">
<pre>
auto tntp = ore::Interpreter::getInp();
</pre>
</div>
　により、<b>tntp</b>には<b>Interpreterクラスのポインタ</b>が代入されます。<br />
　それを使って、<b>Compile()、Exec()、Delete()関数</b>を呼び出します。<br />
　<b>Compile()関数</b>の実体は、以下です。
<div class="box1">
<pre>
    int Interpreter::Compile(FILE *fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;
    }
</pre>
</div>
　このように、お決まりの<b>yyparse()関数</b>を呼び出します。<b>Bison</b>の関数ですね。<br />
　<b>Bisonファイル（つまりoreProject.y）</b>では、<b>index.ore</b>を解析しながら、<b>Interpreterクラスのメンバ関数</b>を呼び出します。<br />
　その具体的な解説は次項で行います。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="03_12.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="03_14.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
