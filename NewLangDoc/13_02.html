<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2020年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>１３．シンプルな実装をする</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>１３－０２．スタックマシンを作成する</h3>
　今回の<b>C言語を作る</b>では、<b>スタックマシン</b>という形で実装しようと思っています。<br />
　<b>スタックマシン</b>というのは、プログラムのコード実行を実装するにあたって、<b>スタック</b>の考え方を利用するということです。<br />
　例えば<b>10+30</b>という演算があった場合、コードの配列は<b>10、30、+</b>と並んでいます。これは<b>.yファイル</b>に演算の優先順位を的確に記述することで、このような並びになります。
　そのとき、スタック操作は
<div class="box1">
<pre>
１、10をpush
２、30をpush
３、プラス演算とわかるので、30をpop
４、10の場所（スタックの先頭）に30を加算
５、結果としてスタックの先頭は40になる
</pre>
</div>
　で、表現できます。<br />
　例えば、そのあと、<b>出力命令</b>があった場合、スタックをpopし（40を取得）、それを出力すればいいことになります。<br />
　基本的にこの考えかたで、スタック操作しながら<b>実行</b>を実装します。
<h4>proc.hの実装</h4>
　<b>CLangProject</b>プロジェクトに<b>proc.h</b>というヘッダファイルを実装します。<br />
　このファイルは<b>C/C++のライブラリや、新規に作成するヘッダファイル</b>をまとめておくヘッダファイルです。<br />
　<b>ヘッダファイル</b>を右クリックし、新規で<b>proc.h</b>を作成し、中に以下を記述します。
<div class="box1">
<pre>
#pragma once

#undef INT8_MIN
#undef INT16_MIN
#undef INT32_MIN
#undef INT8_MAX
#undef INT16_MAX
#undef INT32_MAX
#undef UINT8_MAX
#undef UINT16_MAX
#undef UINT32_MAX

#include &lt;cstdlib>
#include &lt;cstring>
#include &lt;iostream>
#include &lt;fstream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
using namespace std;

#include "stackMachine.h"
</pre>
</div>
　<b>#include "stackMachine.h"</b>のところでエラーになりますが、これから作りますので、そのままにしておきます。<br />
<h4>stackMachine.hの実装</h4>
　続いて<b>ヘッダファイル</b>を右クリックし、新規で<b>stackMachine.h</b>を作成し、中に以下を記述します。
<div class="box1">
<pre>
#pragma once

namespace clg 
{
    //--------------------------------------------------------------------------------------
    ///  ニーモニック
    //--------------------------------------------------------------------------------------
    enum class Mnemonic {
        LDI,    //INT型定数のロード
        DMP,    //デバッグ出力
    };

    //--------------------------------------------------------------------------------------
    ///  値
    //--------------------------------------------------------------------------------------
    union Value{
        int intVal;
        char* pChar;
    };

    //--------------------------------------------------------------------------------------
    ///  オペコード
    //--------------------------------------------------------------------------------------
    struct Opecode {
        Mnemonic mmnic;
        Value val;
    };

    //--------------------------------------------------------------------------------------
    ///  スタックマシンクラス
    //--------------------------------------------------------------------------------------
    class stackMachine {
        vector&lt;Opecode> m_codes;
        vector&lt;Value> m_stack;
        //命令ポインタ
        unsigned int m_ip = 0;
        void stackPush(Value val);
        Value stackPop();
        stackMachine();
    public:
        virtual ~stackMachine();
        int compile(FILE* fp);
        void exec();
        void destroy();
        //インスタンス参照
        static stackMachine* get();
        //何もしない
        void createEmpty();
        /// INTリテラル
        void createIntLiteralExp(const char* ptr);
        //デバッグ出力
        void createDump();
    };
}
//end namespace clg
</pre>
</div>
　<b>clg</b>というnamespaceは<b>CLanguage</b>の略です。<br />
<h4>stackMachine.cppの実装</h4>
　続いて<b>ソースファイル</b>を右クリックし、新規で<b>stackMachine.cpp</b>を作成し、以下を記述します。
<div class="box1">
<pre>
#include "proc.h"

namespace clg
{
    //唯一のスタックマシンのインスタンス
    stackMachine* g_pSackMachine;

    stackMachine::stackMachine()
    {}
    stackMachine::~stackMachine() {
    }
    int stackMachine::compile(FILE* fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;

    }
    void stackMachine::exec() {
        if (m_codes.size() &lt;= 0) {
            return;
        }
        while (m_ip &lt; m_codes.size()) {
            Opecode opcode = m_codes[m_ip];
            switch (opcode.mmnic) {
            case Mnemonic::LDI:
                stackPush(opcode.val);
                m_ip++;
                break;
            case Mnemonic::DMP:
                cout &lt;&lt; stackPop().intVal &lt;&lt; endl;
                m_ip++;
                break;
            }
        }
    }

    void stackMachine::destroy() {
        if (g_pSackMachine) {
            delete g_pSackMachine;
            g_pSackMachine = nullptr;
        }
    }

    //インスタンス参照
    stackMachine* stackMachine::get() {
        if (!g_pSackMachine) {
            g_pSackMachine = new stackMachine();
        }
        return g_pSackMachine;
    }
    //スタック操作
    void stackMachine::stackPush(Value val) {
        m_stack.push_back(val);
    }
    Value stackMachine::stackPop() {
        if (m_stack.empty()) {
            cout &lt;&lt; "スタックは空です" &lt;&lt; endl;
            exit(1);
        }
        Value val = m_stack.back();
        m_stack.pop_back();
        return val;
    }

    //何もしない
    void stackMachine::createEmpty(){

    }

    /// INTリテラル
    void stackMachine::createIntLiteralExp(const char* ptr) {
        Opecode code;
        code.mmnic = Mnemonic::LDI;
        code.val.intVal = atoi(ptr);
        m_codes.push_back(code);
    }
    //出力
    void stackMachine::createDump() {
        Opecode code;
        code.mmnic = Mnemonic::DMP;
        m_codes.push_back(code);
    }



}
//end namespace clg
</pre>
</div>
<h4>CLangProject.lの修正</h4>
　続いて、<b>FlexBison</b>プロジェクトの<b>CLangProject.l</b>を以下のように修正します。
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include "CLangProject.tab.h"
#define YY_SKIP_YYWRAP 1
int gLine = 1;
int yywrap(void){ return 1; }

%}
%s COMMENT
%s LINE_COMMENT
%%
&lt;INITIAL>{
    ";"     return SEMICOLON;
    "+"     return ADD;
    "-"     return SUB;
    "*"     return MUL;
    "/"     return DIV;
    "dump"     return DMP;
    "/*"    { BEGIN(COMMENT);}
    [/][/]+ { BEGIN(LINE_COMMENT);}
    [1-9][0-9]* {
        return INT_LITERAL;
    }
    "\n"    {gLine++;}
    [ \t]   ;
    .   { return 0;}
}
&lt;COMMENT>{
    "\n"    {gLine++;}
    "*/" {BEGIN(INITIAL);}
    .   ;
}
&lt;LINE_COMMENT>{
    "\n" { gLine++; BEGIN(INITIAL);}
    .   ;
}
%%
</pre>
</div>
<h4>CLangProject.yの修正</h4>
　続いて<b>CLangProject.y</b>を以下のように書き換えます
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include "../CLangProject/proc.h"
#define YYDEBUG 1
extern int yylex(void);
extern char *yytext;
int yyerror(char const *str){
    extern int gLine;
    fprintf(stderr,"%s, line: %d, near %s\n",str, gLine, yytext);
    return 0;
}
%}
%code requires {
#include "../CLangProject/proc.h"
}
%union {
    const char* fixedString;
}
%token &lt;fixedString> INT_LITERAL DMP SEMICOLON ADD SUB MUL DIV
%type intliteral_expression 
%type statement statement_list
%%
statement_list
    : statement
    | statement_list statement
    ;
statement
    : SEMICOLON
    | intliteral_expression SEMICOLON
    {
        clg::stackMachine::get()->createEmpty();
    }
    | DMP intliteral_expression SEMICOLON
    {
        clg::stackMachine::get()->createDump();
    }
    ;
intliteral_expression
    : INT_LITERAL
    {
        clg::stackMachine::get()->createIntLiteralExp(yytext);
    }
    ;
%%
</pre>
</div>
<h4>main.cppの修正</h4>
　<b>main.cpp</b>を以下のように修正します。<b>スタックマシン</b>用に
<div class="box1">
<pre>
１、コンパイル（p-code作成 ）
２、実行
３、後始末
</pre>
</div>
　をの3つのステップを実装したものです。<br/>
　<b>p-code</b>というのは、アセンブラのニーモニックを模した、命令文です。しかし、アセンブラ言語ではありません。アセンブラのように<b>ニーモニックと最低限のデータ領域</b>で構成された<b>命令</b>が並んだものです。<br />
　これは<b>バイナリデータ</b>として保存可能です。<br />
　<b>JavaやC#</b>もこういった<b>p-code</b>を使用しています。<b>p-code</b>をスタック上で実行するシステムが<b>スタックマシン</b>です。<b>JavaやC#</b>も<b>スタックマシン</b>です。<br />
　では、修正後の<b>main.cpp</b>です。
<div class="box1">
<pre>
#include "proc.h"

class InputParser {
    vector &lt;string> m_tokens;
public:
    InputParser(int& argc, char** argv) {
        for (int i = 1; i &lt; argc; ++i) {
            m_tokens.push_back(string(argv[i]));
        }
    }
    const string& getCmdOption(const string& option) const {
        vector&lt;string>::const_iterator itr;
        itr = find(m_tokens.begin(), m_tokens.end(), option);
        if (itr != m_tokens.end() && ++itr != m_tokens.end()) {
            return *itr;
        }
        static const string empty_string("");
        return empty_string;
    }
    bool cmdOptionExists(const string& option) const {
        return find(m_tokens.begin(), m_tokens.end(), option)
            != m_tokens.end();
    }
};


int main(int argc, char** argv) {
    InputParser input(argc, argv);
    const string& filename = input.getCmdOption("-f");
    if (filename.empty()) {
        cout &lt;&lt; "スクリプトファイルが指定されていません。" &lt;&lt; endl;
        return 1;
    }
    errno_t err;
    FILE* fp;
    if ((err = fopen_s(&fp, filename.c_str(), "r")) != 0) {
        cout &lt;&lt; "スクリプトファイルの読み込みに失敗しました。" &lt;&lt; endl;
        return 1;
    }
    auto tntp = clg::stackMachine::get();
    if (tntp->compile(fp)) {
        return 1;
    }
    tntp->exec();
    tntp->destroy();
    return 0;
}
</pre>
</div>
<h4>警告無視設定の解除</h4>
　ここまでの修正で<b>CLangProject</b>の<b>プロパティ</b>に設定されている。<b>4996警告の無視</b>の設定を解除できます。<br />
　<b>CLangProject</b>を右ボタンクリックで<b>プロパティ</b>を選び、<b>C/C++－詳細設定</b>メニューの<b>指定の警告を無視する</b>に記載されている<b>4996</b>を削除（記述を消す）してください。<b>プロパティ</b>の設定が終わったら<b>適用</b>ボタンを押して<b>OK</b>します。<br />
<h4>スクリプトファイル、index.cの修正</h4>
　最後に、スクリプトファイルである<b>index.c</b>を修正します。
<div class="box1">
<pre>
dump 10;
</pre>
</div>
　この1行のみです。<br />
　前項にはあった四則演算すらなくなっています。現時点で<b>数字を表示する</b>以外に何もできません。<b>C言語</b>の文法にも何も乗っ取っていません。<br />
　しかし<b>スタックマシン</b>を作成するための<b>土台</b>のようなものはこれで完成です。次項では、またあらためて<b>四則演算</b>の実装を行いたいと思います。<br />
　以下現時点での<b>ソリューションエクスプローラ</b>の画面です。
<p>&nbsp;</p>
<img src="img/130201.png" width="40%" border="1"/>
<p>図130201</p>
<p>&nbsp;</p>

<h4>解説</h4>
　今回の修正で<b>スタックマシン</b>のための基本的な部分の実装を行いました。ここでは<b>スタックマシン</b>について、簡単に説明したいと思います。<br />
<h4>アセンブラについて</h4>
　<b>スタックマシン</b>の説明をする前に、<b>x86もしくはx64のアセンブラ</b>に少し触れたいと思います。<br />
　<b>VisualStdioのC/C++</b>はネイティブなコンパイラなので、例えばWindowsでビルドすれば、多くの場合<b>x86もしくはx64アーキテクチャのマシン語</b>にコンパイルされます。<b>x86</b>は32ビット、<b>x64</b>は64ビットのCPUです。<b>マシン語</b>というのは、単なる数字の並びです。<b>実行命令そのもの</b>も<b>数字</b>で表現したものです。<br />
　ネイティブコンパイルされた<b>実行ファイル（.exe）</b>が、<b>実行</b>されると、メモリ上にファイルがロードされます。プログラムのファイル中には、<b>実行されるマシン語</b>のほかに、データ領域も入ってますが、ここではデータ領域のはなしは省略します。<br />
　<b>実行されるマシン語</b>がロードされるのは<b>コードセグメント</b>と呼ばれるメモリ領域です。実行されることが前提の領域で、ロードが終わると、その領域の中の最初に実行する位置のアドレスが<b>EIP</b>という<b>レジスタ</b>にセットされます。<br />
　CPUは、この<b>レジスタ</b>と<b>メモリ（メインメモリでもよい）</b>と<b>IOポート</b>の3つしか操作できません。<b>メモリ</b>はそのまんまなのでわかると思います。<b>IOポート</b>は、外部機器のインターフェイスです。ディスプレイ、キーボード、HDDなどはすべてこの<b>IOポート</b>をインターフェイスとした、その先につながっています。<br />
　<b>レジスタ</b>とはCPU内部にある<b>計算するためのメモリ</b>です。メインメモリと違って、レジスタはとっても小さな領域です。せいぜい10個から20個くらいの数しかなく、1つのレジスタの大きさは32ビット幅もしくは64ビット幅です。<br />
　<b>コードセグメント</b>にロードされたマシン語は、アセンブラで表現すると、例えば以下のように並んでいます。1行が1つの命令です。32ビットの例です。
<div class="box1">
<pre>
MOV EAX,30      ; EAXレジスタに30をロード
MOV EDX,10      ; EDXレジスタに10をロード
ADD EAX,EDX     ; EAXにEDXを加算してEAXの保存
</pre>
</div>
　このような命令が並んでいるコードを実行する場合、これらとは別に<b>命令ポインタ</b>である<b>EIPレジスタ</b>に先頭行のアドレスをセットすることで実行されます。（JMP命令などでセットする）<br />
　最初に<b>EAXレジスタ</b>に<b>40</b>という値がセットされます。すると<b>EIPレジスタ</b>には<b>次の命令文のアドレス</b>が入ります。<br />
　次の命令は<b>EDXレジスタ</b>に<b>10</b>をセットせよという命令です。続く命令が加算命令です。<br />
　このように<b>レジスタ</b>に演算する値を<b>ロード</b>したあと、演算する仕組み（ネイティブマシン語のプログラム）を、<b>レジスタマシン</b>といいます。<br />
<h4>スタックマシン</h4>
　しかし、今回作成する<b>C言語システム</b>は<b>スタックマシン</b>という仕組みを使います。<br />
　スタックマシンは、例えば以下のように命令が並んでいます。
<div class="box1">
<pre>
LDI 30
LDI 10
ADD
</pre>
</div>
　スタックマシンの命令コードは自由に決められます。ですが、先人たちの経験に習ったほうが、よりベターかと思います。<br />
　ここで<b>LDI</b>というのは<b>整数をロードしなさい</b>という意味です。<b>何を</b>の部分が<b>30</b>です。<b>レジスタマシン</b>のように<b>CPU内部</b>のレジスタを使って命令を実行するわけではありません。
<div class="box1">
<pre>
LDI 30
</pre>
</div>
　は実行時は<b>スタックに30をpush</b>します。続く
<div class="box1">
<pre>
LDI 10
</pre>
</div>
　で<b>スタックに10をpush</b>します。次の命令は
<div class="box1">
<pre>
ADD
</pre>
</div>
　です。ここで<b>スタックをpop</b>します。これで、<b>10がpop</b>されます。<br />
　<b>加算命令</b>はpopされた値と、次のスタックの先頭を加算し、スタックの先頭に結果を代入します。<br />
　<b>10</b>をpopしたあとは、先頭は<b>30</b>ですので、その30に10を足します（追加算）。結果としてスタックの先頭が<b>40</b>になります。<br />
<br />
<h4>この項の実装</h4>
　この項の実装では、まだ四則演算は実装されていません（次項で実装する予定です）。<br />
　実装されているのは<b>整数を表示（出力）する</b>というものです。<br />
　まず、スクリプトファイル<b>index.c</b>を見てみましょう
<div class="box1">
<pre>
dump 10;
</pre>
</div>
　<b>dump</b>という記述は<b>デバッグ用ダンプ出力</b>という意味です。このシステム独自のものです。<b>C言語</b>では<b>文字の出力</b>は一般的には<b>printf関数</b>を使うかと思いますが、まだ関数呼び出しなどの仕組みができてないので、動作確認のための文として<b>dump</b>を用意したわけです。<br />
　しばらく動作確認の出力などはこの<b>dump</b>で行います。<br />
　この単純なスクリプトは、まず<b>Flex</b>によって<b>CLangProject.l</b>に定義された形で<b>トークン</b>に分けられます。<br />
　<b>"dump"</b>という文字列は、トークン名<b>DMP</b>として処理されます。また<b>10</b>は<b>INT_LITERAL</b>、行末の<b>;</b>は、<b>SEMICOLON</b>として処理されます。そのあとに四則演算の記号が並んでますが、この項では使ってません。<br />
　<b>CLangProject.l</b>でトークンに分けられたあと<b>CLangProject.y</b>で<b>構文解析</b>が行われます。<br />
　<b>.yファイル</b>は、これまでも何度か説明してきましたが、<b>優先順位の高い演算</b>は<b>下のほう</b>に記述します。<br />
　<b>CLangProject.y</b>の一番下には

<div class="box1">
<pre>
intliteral_expression
    : INT_LITERAL
    {
        clg::stackMachine::get()->createIntLiteralExp(yytext);
    }
    ;
</pre>
</div>
　という記述があります。これは、<b>INT_LITERALはintliteral_expression（初期化式）</b>というタイプ（分類）に属し、これは
<div class="box1">
<pre>
INT_LITERALはintliteral_expression（初期化式）というタイプ（分類）に属し、
これは、clg::stackMachine::get()->createIntLiteralExp(yytext);
という関数呼び出しで処理される
</pre>
</div>
　という意味です。<b>yytext</b>はトークン分けされた文字列です。<br />
　この関数は、<b>stackMachine.cpp</b>に実態があり、以下のように記述されます
<div class="box1">
<pre>
    /// INTリテラル
    void stackMachine::createIntLiteralExp(const char* ptr) {
        Opecode code;
        code.mmnic = Mnemonic::LDI;
        code.val.intVal = atoi(ptr);
        m_codes.push_back(code);
    }
</pre>
</div>
　<b>yytext</b>という引数は<b>ptr</b>として渡されます。<br />
　ここでは先ほど紹介した<b>LDI</b>命令文として、新しく作成され、<b>m_codes配列</b>の末尾に追加されます。<br />
　<b>レジスタマシン</b>もそうですが、<b>LDI</b>などの構文は<b>ニーモニック</b>といいます。このスタックマシンの<b>ニーモニック</b>
は、<b>stackMachine.h</b>に<b>enum class</b>として宣言されています。
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    ///  ニーモニック
    //--------------------------------------------------------------------------------------
    enum class Mnemonic {
        LDI,    //INT型定数のロード
        DMP,    //デバッグ出力
    };
</pre>
</div>
　現在、定義されているニーモニックは2つだけです。<b>LDI</b>と、<b>デバッグ出力</b>の<b>DMP</b>のみとなっています。<br />
　<b>createIntLiteralExp()関数</b>では、<b>Mnemonic::LDI</b>というニーモニックを設定し、<b>union（共有体）</b>として宣言されている<b>code.val.intVal</b>に<b>atoi</b>によって<b>数値</b>に変換された値をセットします。<br />
　<b>ptr</b>にわたってくるのは<b>数字文字列</b>なので、それを<b>数値（整数）</b>に変換する必要があります。<br />
<br/>
　<b>CLangProject.y</b>では<b>intliteral_expression</b>として分類されたタイプを
<div class="box1">
<pre>
    | DMP intliteral_expression SEMICOLON
    {
        clg::stackMachine::get()->createDump();
    }
    ;
</pre>
</div>
　のように<b>DMP intliteral_expression SEMICOLON</b>という並びで記述すると<b>DMP実行文</b>として実行する、という意味になります。<br />
　<b>index.c</b>に記述される
<div class="box1">
<pre>
dump 10;
</pre>
</div>
　は、まさにこの構文が記述されています。<b>DMP</b>ブロックで呼ばれる<b>clg::stackMachine::get()->createDump()</b>は、以下のような記述です。
<div class="box1">
<pre>
    //出力
    void stackMachine::createDump() {
        Opecode code;
        code.mmnic = Mnemonic::DMP;
        m_codes.push_back(code);
    }
</pre>
</div>
　ここで、ニーモニックは<b>Mnemonic::DMP</b>です。しかし<b>createIntLiteralExp()関数</b>で記述したような<b>code.val.intValへのセット</b>などは行う必要がありません。<br />
　<b>スタックマシン</b>では、多くの命令で、<b>レジスタマシン</b>の<b>AXとDXを足す</b>のように<b>演算対象</b>などは記述する必要がないのです。<br />
　<b>pushとpopを駆使する</b>ことで、多くの命令が実行できます。<br />
<br />
　<b>CLangProject.y</b>による構文解析は、<b>stackMachine::compile()関数</b>で行われます。ここでは、各<b>clg::stackMachine::get()->create...</b>系の関数によって<b>m_codes</b>に命令コードが蓄積されます。
<div class="box1">
<pre>
    int stackMachine::compile(FILE* fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;
    }
</pre>
</div>
<h4>この項の実行</h4>
　実際の実行は<b>stackMachine::exec()関数</b>によって行われます
<div class="box1">
<pre>
    void stackMachine::exec() {
        if (m_codes.size() &lt;= 0) {
            return;
        }
        while (m_ip &lt; m_codes.size()) {
            Opecode opcode = m_codes[m_ip];
            switch (opcode.mmnic) {
            case Mnemonic::LDI:
                stackPush(opcode.val);
                m_ip++;
                break;
            case Mnemonic::DMP:
                cout &lt;&lt; stackPop().intVal &lt;&lt; endl;
                m_ip++;
                break;
            }
        }
    }
</pre>
</div>
　ここでは、<b>命令ポインタ</b>である<b>m_ip</b>が有効な間、<b>ニーモニック</b>によりswitch文で分岐しながらループします。<br />
　<b>Mnemonic::LDI</b>では、<b>stackPush()</b>で<b>スタックにpush</b>します。<br/>
　<b>nemonic::DMP</b>では、<b>stackPop()</b>で取得した値を<b>cout出力ストリーム（C++の関数）</b>によって出力します。<br/>
<h4>後始末</h4>
　<b>コンパイル、実行</b>が追わったら、<b>後始末</b>を行います。<b>main.cpp</b>では後始末の関数として
<div class="box1">
<pre>
    if (tntp->compile(fp)) {
        return 1;
    }
    tntp->exec();
    <span class="red">tntp->destroy();</span>
</pre>
</div>
　赤くなっている部分が<b>後始末</b>の関数呼び出しです。内容は以下です
<div class="box1">
<pre>
    void stackMachine::destroy() {
        if (g_pSackMachine) {
            delete g_pSackMachine;
            g_pSackMachine = nullptr;
        }
    }
</pre>
</div>
　ここで参照している<b>g_pSackMachine</b>は<b>stackMachineのインスタンス</b>です。シングルトンとして作成されます。<br />
　stackMachine::get()関数により、1回目の参照で、newされますので、実行が追わったら、<b>delete</b>する必要があります。<br />
　以上、スタックマシンについても詳しく述べたつもりです。<br />
　次項では、またあらためて<b>四則演算</b>を実装したいと思います。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="13_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="13_03.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
