<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2020年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>１３．シンプルな実装をする</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>１３－０３．デバッグ出力を実装する</h3>
　この項では、<b>文や式</b>という概念や、マネージャ的存在である<b>StackMachineクラス</b>の実装をします。<br />
　合わせて<b>デバッグ出力</b>を実装する<b>dump命令</b>を実装します。<b>dump命令</b>は<b>C言語</b>の文法にはありません。しかし、言語開発途中において、実行途中の変数の状態やさまざまなデータの状態を監視するのに、こういう機能があると便利です。<br />
　<b>C言語</b>は文法上、実行単位は<b>関数ごと</b>に行われます。つまり、グローバル領域に<b>実行文</b>は記述できません。通常グローバル領域には<b>関数宣言</b>や<b>データの初期化</b>を記述します。しかし<b>dump命令</b>はグローバル領域に記述しても、その時の変数などの状態を出力することができます。<b>C言語</b>の代表的な出力命令（関数）は<b>printf関数</b>ですが、これは、後ほど<b>関数</b>として実装します。<br />
　今回の記述は、今後の制作のもとになるヘッダファイルやcppファイルを新しく作成するなどして、開発環境を整える、という役割も果たします。<br />
<h4>CLangProject.l</h4>
　まず<b>CLangProject.l</b>（Flexファイル）です、以下のように書き換えます。
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include "CLangProject.tab.h"
#define YY_SKIP_YYWRAP 1
int gLine = 1;
int yywrap(void){ return 1; }

%}
%s COMMENT
%s LINE_COMMENT
%%
&lt;INITIAL>{
    ";"     return SEMICOLON;
    "+"     return ADD;
    "-"     return SUB;
    "*"     return MUL;
    "/"     return DIV;
    "dump"     return DMP;
    "/*"    { BEGIN(COMMENT);}
    [/][/]+ { BEGIN(LINE_COMMENT);}
    [1-9][0-9]* {
        return INT_LITERAL;
    }
    "\n"    {gLine++;}
    [ \t]   ;
    .   { return 0;}
}
&lt;COMMENT>{
    "\n"    {gLine++;}
    "*/" {BEGIN(INITIAL);}
    .   ;
}
&lt;LINE_COMMENT>{
    "\n" { gLine++; BEGIN(INITIAL);}
    .   ;
}
%%
</pre>
</div>
　続いて<b>Bison</b>ファイルの<b>CLangProject.y</b>ですが、以下のようになります。
<h4>CLangProject.y</h4>
 <div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include "../CLangProject2/proc.h"
#define YYDEBUG 1
extern int yylex(void);
extern char *yytext;
int yyerror(char const *str){
    extern int gLine;
    fprintf(stderr,"%s, line: %d, near %s\n",str, gLine, yytext);
    return 0;
}
%}
%code requires {
#include "../CLangProject2/proc.h"
}
%union {
    const char* fixedString;
    clg::Expression* pExpression;
    clg::Statement* pStatement;
    clg::StatementList* pStatementList;
    clg::Root* pRoot;
}
%token &lt;fixedString> INT_LITERAL DMP SEMICOLON ADD SUB MUL DIV
%type &lt;fixedString> constant 
%type &lt;pExpression> intliteral_expression 
%type &lt;pStatement>  dump_statement statement
%type &lt;pStatementList> statement_list
%type &lt;pRoot> root
%type expression_statement   
%%
root
    :statement_list
    {
        $$ = clg::StackMachine::get()->createRoot($1);
    }
    ;
statement_list
    : statement
    {
        $$ = clg::StackMachine::get()->createStatementList($1);
    }
    | statement_list statement
    {
        $$ = clg::StackMachine::get()->createStatementList($1,$2);
    }
    ;
statement
    : expression_statement
    | dump_statement
    ;
expression_statement
    : SEMICOLON
    |intliteral_expression SEMICOLON
    {
        clg::StackMachine::get()->createEmptyStm();
    }
    ;
dump_statement
    :DMP intliteral_expression SEMICOLON
    {
        $$ = clg::StackMachine::get()->createDumpStm($2);
    }
    ;
intliteral_expression
    : constant
    {
       $$ = clg::StackMachine::get()->createIntLiteralExp($1);
    }
    ;
constant
    :INT_LITERAL
    {
       $$ = yytext;
    }
    ;
%%
</pre>
</div>
　ここから、新しいファイルをいくつか作成します。いずれも<b>CLangProjectプロジェクト</b>内です。<br />
　まずヘッダファイルです。<b>ヘッダー ファイル</b>フィルタに、以下のファイルを作成します。
<h4>proc.h</h4>
 <div class="box1">
<pre>
#pragma once

#undef INT8_MIN
#undef INT16_MIN
#undef INT32_MIN
#undef INT8_MAX
#undef INT16_MAX
#undef INT32_MAX
#undef UINT8_MAX
#undef UINT16_MAX
#undef UINT32_MAX

#include &lt;cstdlib>
#include &lt;cstring>
#include &lt;iostream>
#include &lt;fstream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
using namespace std;

#include "common.h"
#include "expression.h"
#include "statement.h"
#include "stackMachine.h"
</pre>
</div>
<h4>common.h</h4>
 <div class="box1">
<pre>
#pragma once

namespace clg {

#define ORE_MAX_TOKEN_LEN 255

    ///stringを255文字に切り詰める
    inline string clampToken(const char* ext) {
        string str(ext);
        if (str.size() > ORE_MAX_TOKEN_LEN) {
            str.erase(ORE_MAX_TOKEN_LEN);
        }
        return str;
    }

    //--------------------------------------------------------------------------------------
    ///  値タイプ
    //--------------------------------------------------------------------------------------
    enum class ValueType {
        voidVal = 0,
        boolVal,
        intVal,
        doubleVal,
    };


    //--------------------------------------------------------------------------------------
    ///  値
    //--------------------------------------------------------------------------------------
    struct Value {
        ValueType m_type;
        union {
            bool boolV;
            int intV;
            double doubleV;
        };
        explicit Value();
        explicit Value(bool b);
        explicit Value(int i);
        explicit Value(double d);
        Value(const Value& other);
        Value& operator=(const Value& other);
        ~Value() {}
    };


    //--------------------------------------------------------------------------------------
    ///  ステートメントレスポンスタイプ
    //--------------------------------------------------------------------------------------
    enum class SmtResType {
        voidType,
    };

    //--------------------------------------------------------------------------------------
    ///  ステートメントレスポンス
    //--------------------------------------------------------------------------------------
    struct SmtRes {
        SmtResType m_type;
        Value m_retValue;
        SmtRes() :
            m_type(SmtResType::voidType),
            m_retValue() {}
    };

    //--------------------------------------------------------------------------------------
    ///  Objectベース（基底クラス）
    //--------------------------------------------------------------------------------------
    class ObjBase {
    protected:
        ObjBase() {}
    public:
        virtual ~ObjBase() {}
    };

}
//end namespace clg
</pre>
</div>
<h4>expression.h</h4>
 <div class="box1">
<pre>
#pragma once

namespace clg {

    //--------------------------------------------------------------------------------------
    ///  式クラス
    //--------------------------------------------------------------------------------------
    class Expression : public ObjBase {
    protected:
        Expression() {}
    public:
        virtual ~Expression() {}
        virtual Value execute() {
            return Value();
        }
    };

    //--------------------------------------------------------------------------------------
    ///  intリテラル式クラス
    //--------------------------------------------------------------------------------------
    class IntLiteralExp : public Expression {
        int m_intValue;
    public:
        IntLiteralExp(int i = 0) {
            m_intValue = i;
        }
        virtual ~IntLiteralExp() {}
        virtual Value execute() override;
    };
}
//end namespace clg
</pre>
</div>
<h4>statement.h</h4>
 <div class="box1">
<pre>
#pragma once

namespace clg {

    //--------------------------------------------------------------------------------------
    ///  文クラス
    //--------------------------------------------------------------------------------------
    class Statement : public ObjBase {
    protected:
        Statement() {}
    public:
        virtual ~Statement() {}
        //voidの実行関数
        virtual SmtRes execute(){
            return SmtRes();
        }
    };

    //--------------------------------------------------------------------------------------
    ///  Dump文クラス
    //--------------------------------------------------------------------------------------
    class DumpStm : public Statement {
        Expression* m_expression;
    public:
        DumpStm(Expression* exp):
            m_expression(exp)
        {}
        //実行関数
        virtual SmtRes execute() override;
        virtual ~DumpStm() {}
    };


    //--------------------------------------------------------------------------------------
    ///  文リストクラス
    //--------------------------------------------------------------------------------------
    class StatementList : public ObjBase {
        Statement* m_Statement;
        StatementList* m_Next;
    public:
        StatementList(Statement* stm):
            m_Statement(stm),
            m_Next(nullptr)
        {

        }
        Statement* getStm() const {
            return m_Statement;

        }
        StatementList* getNext()const {
            return m_Next;
        }
        void setNext(StatementList* next) {
            m_Next = next;
        }
        virtual ~StatementList() {}
    };
}
//end namespace clg
</pre>
</div>
<h4>stackMachine.h</h4>
 <div class="box1">
<pre>
#pragma once

namespace clg
{

    //--------------------------------------------------------------------------------------
    ///  ルートクラス
    //--------------------------------------------------------------------------------------
    class Root : public ObjBase {
        StatementList* m_pStatementList;
    public:
        Root(StatementList* stml):
            m_pStatementList(stml)
        {}
        virtual ~Root() {}
        SmtRes execute();
        StatementList* getStmeList()const {
            return m_pStatementList;
        }
    };

    //--------------------------------------------------------------------------------------
    ///  スタックマシンクラス
    //--------------------------------------------------------------------------------------
    class StackMachine {
        //命令ポインタ
        unsigned int m_ip = 0;
        //ルートオブジェクト
        Root* m_pRoot;
        //オブジェクトのプール
        vector&lt;ObjBase*> m_objPool;
        StackMachine();
    public:
        virtual ~StackMachine();
        int compile(FILE* fp);
        void execute();
        void destroy();
        //インスタンス参照
        static StackMachine* get();
        //式
        /// INTリテラル
        Expression* createIntLiteralExp(const char* ptr);
        //文
        //何もしない文
        void createEmptyStm();
        //デバッグ出力
        Statement* createDumpStm(Expression* exp);
        //文リスト
        StatementList* createStatementList(Statement* stm);
        StatementList* createStatementList(StatementList* stml,Statement* stm);
        //ルートオブジェクト
        Root* createRoot(StatementList* stml);

    };
}
//end namespace clg
</pre>
</div>
　続いてソースファイルです<b>CLangProject</b>プロジェクトの<b>ソースファイル</b>フィルタに以下のファイルを追加します。
<h4>common.cpp</h4>
 <div class="box1">
<pre>
#include "proc.h"

namespace clg {

    Value::Value()
    {
        m_type = ValueType::voidVal;
        intV = 0;
    }

    Value::Value(bool b)
    {
        m_type = ValueType::boolVal;
        boolV = b;
    }

    Value::Value(int i)
    {
        m_type = ValueType::intVal;
        intV = i;
    }

    Value::Value(double d)
    {
        m_type = ValueType::doubleVal;
        doubleV = d;
    }


    Value::Value(const Value& other)
    {
        *this = other;
    }

    Value& Value::operator=(const Value& other) {
        if (this != &other) {
            *this = other;
        }
        return *this;
    }
}
//end namespace ore
</pre>
</div>
<h4>expression.cpp</h4>
<div class="box1">
<pre>
#include "proc.h"

namespace clg {

    Value IntLiteralExp::execute(){
        return Value(m_intValue);
    }


}
//end namespace clg
</pre>
</div>

<h4>statement.cpp</h4>
 <div class="box1">
<pre>
#include "proc.h"

namespace clg
{
    SmtRes DumpStm::execute() {
        if (m_expression) {
            auto val = m_expression->execute();
            switch (val.m_type) {
            case ValueType::intVal:
                cout &lt;&lt; val.intV &lt;&lt; endl;
                break;
            }
        }
        return SmtRes();
    }

}
// end namespace clg
</pre>
</div>
<h4>stackMachine.cpp</h4>
 <div class="box1">
<pre>
#include "proc.h"

namespace clg
{

    SmtRes Root::execute() {
        if (m_pStatementList) {
            auto pos = m_pStatementList;
            do {
                auto stm = pos->getStm();
                stm->execute();
                pos = pos->getNext();
            } while (pos);
        }
        return SmtRes();
    }

    //唯一のスタックマシンのインスタンス
    StackMachine* g_pSackMachine;

    StackMachine::StackMachine()
    {}
    StackMachine::~StackMachine() {
        for (size_t i = 0; i &lt; m_objPool.size(); i++) {
            delete m_objPool[i];
        }
        m_objPool.clear();
    }
    int StackMachine::compile(FILE* fp) {
        extern int yyparse(void);
        extern FILE* yyin;
        yyin = fp;
        if (yyparse()) {
            return 1;
        }
        return 0;

    }
    void StackMachine::execute() {
        if (m_pRoot) {
            m_pRoot->execute();
        }
    }

    void StackMachine::destroy() {
        if (g_pSackMachine) {
            delete g_pSackMachine;
            g_pSackMachine = nullptr;
        }
    }

    //インスタンス参照
    StackMachine* StackMachine::get() {
        if (!g_pSackMachine) {
            g_pSackMachine = new StackMachine();
        }
        return g_pSackMachine;
    }

    //何もしない
    void StackMachine::createEmptyStm() {

    }

    /// INTリテラル
    Expression* StackMachine::createIntLiteralExp(const char* ptr) {
        string str = clampToken(ptr);
        auto pObj = new IntLiteralExp(std::stoi(str));
        m_objPool.push_back(pObj);
        return pObj;
    }


    //出力
    Statement* StackMachine::createDumpStm(Expression* exp) {
        auto pObj = new DumpStm(exp);
        m_objPool.push_back(pObj);
        return pObj;
    }

    StatementList* StackMachine::createStatementList(Statement* stm) {
        auto pObj = new StatementList(stm);
        m_objPool.push_back(pObj);
        return pObj;
    }

    StatementList* StackMachine::createStatementList(StatementList* stml, Statement* stm) {
        StatementList* pos;
        if (stml == nullptr)
            return createStatementList(stm);
        for (pos = stml; pos->getNext(); pos = pos->getNext())
            ;
        pos->setNext(createStatementList(stm));
        return stml;
    }

    //ルート
    Root* StackMachine::createRoot(StatementList* stml) {
        m_pRoot = new Root(stml);
        return m_pRoot;
    }

}
//end namespace clg

</pre>
</div>
　<b>main.cpp</b>は以下のように書き換えます。
<h4>main.cpp</h4>
<div class="box1">
<pre>
#include "proc.h"

class InputParser {
    vector &lt;string> m_tokens;
public:
    InputParser(int& argc, char** argv) {
        for (int i = 1; i &lt; argc; ++i) {
            m_tokens.push_back(string(argv[i]));
        }
    }
    const string& getCmdOption(const string& option) const {
        vector&lt;string>::const_iterator itr;
        itr = find(m_tokens.begin(), m_tokens.end(), option);
        if (itr != m_tokens.end() && ++itr != m_tokens.end()) {
            return *itr;
        }
        static const string empty_string("");
        return empty_string;
    }
    bool cmdOptionExists(const string& option) const {
        return find(m_tokens.begin(), m_tokens.end(), option)
            != m_tokens.end();
    }
};


int main(int argc, char** argv) {
    InputParser input(argc, argv);
    const string& filename = input.getCmdOption("-f");
    if (filename.empty()) {
        cout &lt;&lt; "スクリプトファイルが指定されていません。" &lt;&lt; endl;
        return 1;
    }
    errno_t err;
    FILE* fp;
    if ((err = fopen_s(&fp, filename.c_str(), "r")) != 0) {
        cout &lt;&lt; "スクリプトファイルの読み込みに失敗しました。" &lt;&lt; endl;
        return 1;
    }
    auto tntp = clg::StackMachine::get();
    if (tntp->compile(fp)) {
        return 1;
    }
    tntp->execute();
    tntp->destroy();
    return 0;
}
</pre>
</div>
　あと<b>CLangProject.flex.cpp</b>および<b>CLangProject.tab.cpp</b>は<b>FlexとBison</b>が作り出すファイルなので、そのままにしておきます。<br />
　最後に、スクリプトファイルの<b>index.c</b>です。以下の1行のみになります。
<h4>index.c</h4>
<div class="box1">
<pre>
dump 10;
</pre>
</div>
　<b>.c</b>という拡張子のファイルなので<b>VisualStdio</b>はエラーを表示しますが、コンパイルには含めていないので、無視してかまいません。<br />
　すべて記述が終わったら<b>リビルド</b>します。<br />
　エラーがなく<b>リビルド</b>できれば成功です。<br />
　<b>デバッグなしで開始</b>すると
<div class="box1">
<pre>
10

...\CLangProject.exe (プロセス 16592) は、コード 0 で終了しました。
このウィンドウを閉じるには、任意のキーを押してください...
</pre>
</div>
　と出れば実行も成功です。<br />
　それでは、次項からは、今項で作成したファイルを修正しながら<b>C言語</b>を実装していきます。


</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="13_02.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="13_04.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
