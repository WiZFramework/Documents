<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０４．インタプリタの作成</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０４－０２．value.cpp</h3>
<div class="box1">
<pre>
#include &lt;cstdlib>
#include &lt;cmath>
#include &lt;cfenv>
#include &lt;iostream>
#include &lt;string>
#include &lt;set>
#include &lt;map>
#include &lt;vector>
#include &lt;list>
#include &lt;memory>
#include &lt;typeinfo>
#include "util.h"
#include "proc.h"
using namespace std;

namespace ore {

    //--------------------------------------------------------------------------------------
    ///  暗黙の型キャスト
    //--------------------------------------------------------------------------------------
    inline bool toBoolValue() {
        return false;
    }
    inline bool toBoolValue(bool b) {
        return b;
    }
    inline bool toBoolValue(int i) {
        if (i != 0) {
            return true;
        }
        else {
            return false;
        }
    }
    inline bool toBoolValue(double b) {
        if (b != 0.0) {
            return true;
        }
        else {
            return false;
        }
    }
    inline bool toBoolValue(const string& str) {
        //必ず10進数に変換
        int i;
        try {
            i = std::stoi(str, nullptr, 10);
        }
        catch (...) {
            i = 0;
        }
        if (i != 0) {
            return true;
        }
        else {
            return false;
        }
    }

    inline int toIntValue() {
        return 0;
    }

    inline int toIntValue(bool b) {
        if (b != false) {
            return 1;
        }
        else {
            return 0;
        }
    }

    inline int toIntValue(int i) {
        return i;
    }

    inline int toIntValue(double d) {
        //強制的な型返還
        int i = (int)d;
        return i;
    }

    inline int toIntValue(const string& str) {
        //必ず10進数に変換
        int i;
        try {
            i = std::stoi(str, nullptr, 10);
        }
        catch (...) {
            i = 0;
        }
        return i;
    }

    inline double toDoubleValue() {
        return 0.0;
    }

    inline double toDoubleValue(bool b) {
        if (b) {
            return 1.0;
        }
        else {
            return 0.0;
        }
    }

    inline double toDoubleValue(int i) {
        //C++に合わせた型返還
        double d = i;
        return d;
    }

    inline double toDoubleValue(double d) {
        return d;
    }

    inline double toDoubleValue(const string& str) {
        //10進のdoubleに変換
        double d;
        try {
            d = std::stod(str);
        }
        catch (...) {
            d = 0.0;
        }
        return d;
    }

    inline string toStringValue() {
        return string("");
    }

    inline string toStringValue(bool b) {
        if (b) {
            return string("1");
        }
        else {
            return string("");
        }
    }

    inline string toStringValue(int i) {
        string str = std::to_string(i);
        return str;
    }

    inline string toStringValue(double d) {
        string str = std::to_string(d);
        return str;
    }

    inline string toStringValue(const string& str) {
        return str;
    }

    //--------------------------------------------------------------------------------------
    ///  値
    //--------------------------------------------------------------------------------------
    struct Value::Impl {
        ValueType m_Type;
        string strV;
        //get用のstring
        string tmpStr;
        union {
            bool boolV;
            int intV;
            double doubleV;
        };
    };

    Value::Value() :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::voidVal;
        pImpl->intV = 0;
    }

    Value::Value(bool b) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::boolVal;
        pImpl->boolV = b;
    }

    Value::Value(int i) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::intVal;
        pImpl->intV = i;
    }

    Value::Value(double d) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::doubleVal;
        pImpl->doubleV = d;
    }

    Value::Value(const char* s) :
        pImpl(new Impl)
    {
        pImpl->m_Type = ValueType::stringVal;
        pImpl->strV = s;
    }

    Value::Value(const Value& other) :
        pImpl(new Impl)
    {
        *pImpl = *(other.pImpl);
    }

    Value& Value::operator=(bool b) {
        pImpl->m_Type = ValueType::boolVal;
        pImpl->boolV = b;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(int i) {
        pImpl->m_Type = ValueType::intVal;
        pImpl->intV = i;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(double d) {
        pImpl->m_Type = ValueType::doubleVal;
        pImpl->doubleV = d;
        pImpl->strV = "";
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(const char* s) {
        pImpl->m_Type = ValueType::stringVal;
        pImpl->intV = 0;
        pImpl->strV = s;
        pImpl->tmpStr = "";
        return *this;
    }

    Value& Value::operator=(const Value& other) {
        *pImpl = *(other.pImpl);
        return *this;
    }

    Value::~Value() {
        delete pImpl;
        pImpl = nullptr;
    }

    ValueType Value::getType() const {
        return pImpl->m_Type;
    }

    bool Value::getBool() const {
        switch (getType())
        {
        case ValueType::boolVal:
            return pImpl->boolV;
            break;
        case ValueType::intVal:
            return toBoolValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            return toBoolValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            return toBoolValue(pImpl->strV);
            break;
        }
        return toBoolValue();
    }

    int Value::getInt() const {
        switch (getType()) {
        case ValueType::boolVal:
            return toIntValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            return pImpl->intV;
            break;
        case ValueType::doubleVal:
            return toIntValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            return toIntValue(pImpl->strV);
            break;
        }
        return toIntValue();
    }

    double Value::getDouble() const {
        switch (getType()) {
        case ValueType::boolVal:
            return toDoubleValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            return toDoubleValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            return pImpl->doubleV;
            break;
        case ValueType::stringVal:
            return toDoubleValue(pImpl->strV);
            break;
        }
        return toDoubleValue();
    }

    const char* Value::getString() const {
        switch (getType()) {
        case ValueType::boolVal:
            pImpl->tmpStr = toStringValue(pImpl->boolV);
            break;
        case ValueType::intVal:
            pImpl->tmpStr = toStringValue(pImpl->intV);
            break;
        case ValueType::doubleVal:
            pImpl->tmpStr = toStringValue(pImpl->doubleV);
            break;
        case ValueType::stringVal:
            pImpl->tmpStr = pImpl->strV;
            break;
        default:
            pImpl->tmpStr = toStringValue();
            break;
        }
        return pImpl->tmpStr.c_str();
    }

    Value getOptimalTypeValue(double ret) {
        double mod = std::fmod(ret, 1.0);
        Value eps = Interpreter::getInp()->getConfig("calc_epsilon");
        double epsd = eps.getDouble();
        if (abs(epsd) >= 0.1)epsd = 0.1;
        if (std::fabs(mod) &lt;= epsd) {
            return Value((int)ret);
        }
        return Value(ret);
    }

    Value Value::operator+(const Value& other) {
        double ret((*this).getDouble());
        ret += other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator-(const Value& other) {
        double ret((*this).getDouble());
        ret -= other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator*(const Value& other) {
        double ret((*this).getDouble());
        ret *= other.getDouble();
        return getOptimalTypeValue(ret);
    }

    Value Value::operator/(const Value& other) {
        double other_double = other.getDouble();
        if (other_double == 0.0) {
            Interpreter::getInp()->runtimeExit(2003);
        }
        double ret((*this).getDouble());
        ret /= other_double;
        return getOptimalTypeValue(ret);
    }

    Value Value::operator&(const Value& other) {
        string ret((*this).getString());
        ret += other.getString();
        return Value(ret.c_str());
    }

    Value&  Value::operator&=(const Value& other) {
        *this = *this & other;
        return *this;
    }

    Value& Value::operator+=(const Value& other) {
        *this = *this + other;
        return *this;
    }

    Value& Value::operator-=(const Value& other) {
        *this = *this - other;
        return *this;

    }

    Value& Value::operator*=(const Value& other) {
        *this = *this * other;
        return *this;
    }

    Value& Value::operator/=(const Value& other) {
        *this = *this / other;
        return *this;
    }

    bool  Value::operator == (const Value& other) {
        if (this->getType() == ValueType::stringVal
            && other.getType() == ValueType::stringVal) {
            return (pImpl->strV == other.pImpl->strV);
        }
        if (this->getType() == ValueType::doubleVal
            || other.getType() == ValueType::doubleVal) {
            double left((*this).getDouble());
            double right(other.getDouble());
            return (left == right);
        }
        else if (this->getType() == ValueType::intVal
            || other.getType() == ValueType::intVal){
            int left((*this).getInt());
            int right(other.getInt());
            return (left == right);
        }
        else if (this->getType() == ValueType::boolVal
            || other.getType() == ValueType::boolVal) {
            bool left((*this).getBool());
            bool right(other.getBool());
            return (left == right);
        }
        else {
            return false;
        }
    }

    bool  Value::operator != (const Value& other) {
        return !((*this) == other);
    }

    bool Value::operator &lt; (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left &lt; right);
    }

    bool Value::operator > (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left > right);
    }

    bool Value::operator &lt;= (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left &lt;= right);
    }

    bool Value::operator >= (const Value& other) {
        double left((*this).getDouble());
        double right(other.getDouble());
        return (left >= right);
    }

}
//end namespace ore
</pre>
</div>
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="04_02.html">戻る</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
