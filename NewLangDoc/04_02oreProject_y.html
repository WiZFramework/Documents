<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>言語を作ろうプロジェクト（2019年）</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h3>０４．インタプリタの作成</h3>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>０４－０２．oreProject.y</h3>
<div class="box1">
<pre>
%{
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include "../oreProject/proc.h"
#define YYDEBUG 1
extern int yylex(void);
int yyerror(char const *str){
    extern char *yytext;
    extern int gLine;
    ore::Interpreter::getInp()->syntaxExit(1003, gLine, yytext);
    return 0;
}
%}
%expect 1
%code requires {
#include "../oreProject/proc.h"
}
%union {
    const char* fixedString;
    ore::Expression* expression;
    ore::ArrKeyValueList* arraykeyvalueList;
    ore::ArrKeytList* arraykeyList;
    ore::Statement* statement;
    ore::StatementList* statementList;
    ore::ParameterList* parameterList;
    ore::ArgumentList* argumentList;
    ore::Root* root;
}
%token &lt;fixedString> IDENTIFIER LOCAL_IDENTIFIER
%token &lt;expression>  TRUE_T FALSE_T INT_LITERAL DOUBLE_LITERAL STR_LITERAL
%token LP RP LC RC LB RB EQ NE LE GE LT GT LOGICAL_AND LOGICAL_OR AMP COMMA COLON SEMICOLON ADD SUB MUL DIV MOD CR  
%token MULASS DIVASS  ADDASS SUBASS AMPASS ASS PRINTN PRINT SETCONFIG GETCONFIG ARRAY INCREMENT DECREMENT
%token IF ELSE SWITCH CASE DEFAULT WHILE FOREACH AS FOR BREAK CONTINUE FUNCTION RETURN
%right ASS 
%right ADDASS SUBASS AMPASS
%right MULASS DIVASS
%left LOGICAL_OR
%left LOGICAL_AND
%left ADD SUB 
%left MUL DIV MOD
%left UMINUS
%type &lt;expression> constart_expression identifier_expression identifier_array_expression 
%type &lt;expression> internal_expression primary_expression
%type &lt;expression> postfix_expression unary_expression mul_expression add_expression
%type &lt;expression> relational_expression equality_expression 
%type &lt;expression> logical_and_expression logical_or_expression assign_expression expression   
%type &lt;statement> statement labeled_statement expression_statement compound_statement internal_statement
%type &lt;statement> selection_statement iteration_statement jump_statement function_define_statement
%type &lt;statementList> statement_list
%type &lt;arraykeyvalueList> initialize_array_key_value_list
%type &lt;arraykeyList> arraykey_list
%type &lt;argumentList> argument_list
%type &lt;parameterList> parameter_list
%type &lt;root> root
%%
root
    :statement_list
    {
        $$ = ore::Interpreter::getInp()->createRoot($1);
    }
    ;
statement_list
    : statement
    {
        $$ = ore::Interpreter::getInp()->createStatementList($1);
    }
    | statement_list statement
    {
        $$ = ore::Interpreter::getInp()->createStatementList($1,$2);
    }
    ;
statement
    : labeled_statement
    | expression_statement
    | compound_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | internal_statement
    | function_define_statement
    ;
labeled_statement
    : CASE expression COLON statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::CaseStm>($2,$4);
    }
    | DEFAULT COLON statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::DefaultStm>($3);
    }
    ;
expression_statement
    : SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ExpressionStm>();
    }
    | expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ExpressionStm>($1);
    }
    ;
compound_statement
    : LC RC
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::BlockStm>();
    }
    | LC statement_list RC
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::BlockStm>($2);
    }
    ;
selection_statement
    : IF LP expression RP statement ELSE statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::IfElsStm>($3,$5,$7);
    }
    | IF LP expression RP statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::IfStm>($3,$5);
    }
    | SWITCH  LP expression RP compound_statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::SwitchStm>($3,$5);
    }
    ;
iteration_statement
    : WHILE LP expression RP statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::WhileStm>($3,$5);
    }
    | FOR LP statement expression SEMICOLON expression RP statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ForStm>($3,$4,$6,$8);
    }
    | FOREACH LP identifier_expression AS IDENTIFIER COLON IDENTIFIER RP statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ForeachStm>($3,$5,$7,$9);
    }
    | FOREACH LP identifier_expression AS LOCAL_IDENTIFIER COLON LOCAL_IDENTIFIER RP statement
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ForeachStm>($3,$5,$7,$9);
    }
    ;
jump_statement
    : CONTINUE SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ContinueStm>();
    }
    | BREAK SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::BreakStm>();
    }
    | RETURN SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ReturnStm>();
    }
    | RETURN  expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::ReturnStm>($2);
    }
    ;
internal_statement
    : SETCONFIG LP IDENTIFIER COMMA expression RP SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::SetConfigStm>($3,$5);
    }
    | PRINTN expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::PrintStm>($2,true);
    }
    | PRINT expression SEMICOLON
    {
        $$ = ore::Interpreter::getInp()->createStatement&lt;ore::PrintStm>($2,false);
    }
    ;
function_define_statement
    : FUNCTION IDENTIFIER LP parameter_list RP compound_statement
    {
        $$ = ore::Interpreter::getInp()->createFunctionDefineStm($2,$4,$6);
    }
    ;
parameter_list
    : /*empty*/
    {
        $$ = ore::Interpreter::getInp()->createParameterList();
    }
    | LOCAL_IDENTIFIER
    {
        $$ = ore::Interpreter::getInp()->createParameterList($1);
    }
    | parameter_list COMMA LOCAL_IDENTIFIER
    {
        $$ = ore::Interpreter::getInp()->createParameterList($1,$3);
    }
    ;
expression
    : assign_expression
    ;
assign_expression
    : logical_or_expression
    | identifier_expression ASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createAssExp($1,$3);
    }
    | identifier_array_expression ASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createAssignArrExp($1,$3);
    }
    | identifier_expression ADDASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createToAssExp($1,$3, ore::ExpressionType::addAssExp);
    }
    | identifier_expression SUBASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createToAssExp($1,$3, ore::ExpressionType::subAssExp);
    }
    | identifier_expression AMPASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createToAssExp($1,$3, ore::ExpressionType::ampAssExp);
    }
    | identifier_expression MULASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createToAssExp($1,$3, ore::ExpressionType::mulAssExp);
    }
    | identifier_expression DIVASS assign_expression
    {
        $$ = ore::Interpreter::getInp()->createToAssExp($1,$3, ore::ExpressionType::divAssExp);
    }
    ;
logical_or_expression
    : logical_and_expression
    | logical_or_expression LOGICAL_OR logical_and_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::logicalOrExp);
    }
    ;
logical_and_expression
    : equality_expression
    | logical_and_expression LOGICAL_AND equality_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::logicalAndExp);
    }
    ;
equality_expression
    :relational_expression
    | equality_expression EQ relational_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::eqExp);
    }
    | equality_expression NE relational_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::neExp);
    }
    ;
relational_expression
    : add_expression
    | relational_expression LT add_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::ltExp);
    }
    | relational_expression GT add_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::gtExp);
    }
    | relational_expression LE add_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::leExp);
    }
    | relational_expression GE add_expression
    {
        $$ = ore::Interpreter::getInp()->createRelationalExp($1,$3,ore::ExpressionType::geExp);
    }
    ;
add_expression
    : mul_expression
    | add_expression ADD mul_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::addExp);
    }
    | add_expression SUB mul_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::subExp);
    }
    | add_expression AMP mul_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::ampExp);
    }
    ;
mul_expression
    : unary_expression
    | mul_expression MUL primary_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::mulExp);
    }
    | mul_expression DIV primary_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::divExp);
    }
    | mul_expression MOD primary_expression
    {
        $$ = ore::Interpreter::getInp()->createBinaryExp($1,$3,ore::ExpressionType::modExp);
    }
    ;
unary_expression
    : postfix_expression
    | INCREMENT identifier_expression
    {
        $$ = ore::Interpreter::getInp()->createUnaryIncDecExp($2,ore::ExpressionType::unaInc);
    }
    | DECREMENT identifier_expression
    {
        $$ = ore::Interpreter::getInp()->createUnaryIncDecExp($2,ore::ExpressionType::unaDec);
    }
postfix_expression
    : primary_expression
    | IDENTIFIER LP argument_list RP
    {
        $$ = ore::Interpreter::getInp()->createFunctionCallExp($1,$3);
    }
    | identifier_expression INCREMENT
    {
        $$ = ore::Interpreter::getInp()->createPostfixIncDecExp($1,ore::ExpressionType::posInc);
    }
    | identifier_expression DECREMENT
    {
        $$ = ore::Interpreter::getInp()->createPostfixIncDecExp($1,ore::ExpressionType::posDec);
    }
    ;
primary_expression
    : identifier_array_expression
    | internal_expression
    | identifier_expression
    | constart_expression
    | STR_LITERAL
    {
        $$ = ore::Interpreter::getInp()->createStringLiteralExp();
    }
    | LP expression RP
    {
        $$ = ore::Interpreter::getInp()->createPriorityExp($2);
    }
    ;
internal_expression
    : ARRAY LP argument_list RP
    {
        $$ = ore::Interpreter::getInp()->createArrayInitValueExp($3);
    }
    | ARRAY LP initialize_array_key_value_list RP
    {
        $$ = ore::Interpreter::getInp()->createArrayInitKeyValueExp($3);
    }
    ;
argument_list
    : /*empty*/
    {
        $$ = ore::Interpreter::getInp()->createArgumentList();
    }
    | expression
    {
        $$ = ore::Interpreter::getInp()->createArgumentList($1);
    }
    | argument_list COMMA expression
    {
        $$ = ore::Interpreter::getInp()->createArgumentList($1,$3);
    }
    ;
initialize_array_key_value_list
    : expression COLON expression
    {
        $$ = ore::Interpreter::getInp()->createArrKeyValueList($1,$3);
    }
    | initialize_array_key_value_list COMMA expression COLON expression
    {
        $$ = ore::Interpreter::getInp()->createArrKeyValueList($1,$3,$5);
    }
    ;
identifier_array_expression
    : IDENTIFIER arraykey_list
    {
        $$ = ore::Interpreter::getInp()->createArrayExp($1,$2,false);
    }
    | LOCAL_IDENTIFIER arraykey_list
    {
        $$ = ore::Interpreter::getInp()->createArrayExp($1,$2,true);
    }
    ;
arraykey_list
    : LB RB
    {
        $$ = ore::Interpreter::getInp()->createArrKeytList();
    }
    | LB expression RB
    {
        $$ = ore::Interpreter::getInp()->createArrKeytList($2);
    }
    | arraykey_list LB expression RB
    {
        $$ = ore::Interpreter::getInp()->createArrKeytList($1,$3);
    }
    ;
identifier_expression
    : IDENTIFIER
    {
        $$ = ore::Interpreter::getInp()->createVariableExp($1,false);
    }
    | LOCAL_IDENTIFIER
    {
        $$ = ore::Interpreter::getInp()->createVariableExp($1,true);
    }
    ;
constart_expression
    : DOUBLE_LITERAL
    {
        $$ = $1;
    }
    | INT_LITERAL
    {
        $$ = $1;
    }
    | TRUE_T
    {
        $$ = ore::Interpreter::getInp()->createBoolLiteralExp(true);
    }
    | FALSE_T
    {
        $$ = ore::Interpreter::getInp()->createBoolLiteralExp(false);
    }
    ;
%%
</pre>
</div>

</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="04_02.html">戻る</a></li>
</ul>
<!-- /フッタ　-->
</div>
<!-- /全体コンテナ　-->
</body>
</html>
